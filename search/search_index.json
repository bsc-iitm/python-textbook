{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#programming-in-python","title":"Programming in Python","text":"<p>This is an online textbook on Python and is a companion resource to the course <code>Programming in Python</code> offered as a part of the Online Degree Program, IIT-Madras. For more details about the course, check out our website.</p> <p>Note to students: This book is meant to be used as a reference. You may find content that has not  been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing!</p>"},{"location":"#chapter-0-warm-up","title":"Chapter-0: Warm-up","text":"<p>Lesson-0</p>"},{"location":"#chapter-1-introduction-to-python","title":"Chapter-1: Introduction to Python","text":"<p>Lesson-1.1</p> <ul> <li>Python shell | Replit Console </li> <li>Prompts | Output</li> <li>Emojis</li> <li>Literals and Variables</li> <li>Basic Data types | type()</li> <li>Comments</li> </ul> <p>Lesson-1.2</p> <ul> <li>Operators</li> <li>Convention</li> <li>Expressions</li> <li>Type of Expressions</li> </ul> <p>Lesson-1.3</p> <ul> <li>Arithmetic Expressions</li> <li>Boolean Expressions</li> </ul> <p>Lesson-1.4</p> <ul> <li>Replit Editor</li> <li>Errors | Debugging</li> <li>Exceptions</li> <li>Wrong Code Snippets </li> </ul> <p>Lesson-1.5</p> <ul> <li>Strings</li> <li>Quotes</li> <li>Length</li> <li>Operations</li> <li>Escape Characters</li> <li>Substrings</li> </ul> <p>Lesson-1.6</p> <ul> <li>Strings</li> <li>Indexing</li> <li>Slicing</li> <li>Immutability</li> <li>Methods</li> </ul>"},{"location":"#chapter-2-conditionals","title":"Chapter-2: Conditionals","text":"<p>Lesson-2.1</p> <ul> <li>Variables | Assignment operator | Dynamic Typing</li> <li>Referencing versus Defining | Keywords and Naming Rules</li> <li>Reusing Variables | Multiple Assignment | Deleting Variables</li> </ul> <p>Lesson-2.2</p> <ul> <li>Input</li> <li>Type Conversion | Built-in Functions</li> </ul> <p>Lesson-2.3</p> <ul> <li>Conditional Statements</li> <li><code>if</code></li> <li><code>if-else</code> </li> <li><code>if-elif-else</code></li> <li>Nested Conditional Statements</li> <li>Defining Variables inside <code>if</code></li> </ul> <p>Lesson-2.4</p> <ul> <li>System libraries</li> <li><code>calendar</code></li> <li><code>time</code></li> <li><code>this</code></li> </ul>"},{"location":"#chapter-3-loops","title":"Chapter-3: Loops","text":"<p>Lesson-3.1</p> <ul> <li><code>while</code> loop</li> <li><code>break</code>, <code>continue</code></li> </ul> <p>Lesson-3.2</p> <ul> <li><code>for</code> loop</li> <li><code>range()</code> </li> <li>Iterating through Strings</li> </ul> <p>Lesson-3.3</p> <ul> <li>Nested loops</li> <li><code>while</code> versus <code>for</code></li> <li><code>print</code></li> <li><code>end</code> </li> <li><code>sep</code></li> </ul> <p>Lesson-3.4</p> <ul> <li>Formatted printing</li> <li>f-strings</li> <li><code>format()</code></li> <li>Format Specifiers</li> </ul> <p>Lesson-3.5</p> <p>System libraries</p> <ul> <li><code>math</code></li> <li><code>random</code></li> </ul> <p>Lesson-3.6</p> <p>Mathematics and Programming</p> <ul> <li>Limits</li> <li>Recurrence relations</li> <li>Rational approximation</li> </ul>"},{"location":"#chapter-4-functions","title":"Chapter-4: Functions","text":"<p>Lesson-4.1</p> <ul> <li>Introduction</li> <li>Examples</li> </ul> <p>Lesson-4.2</p> <ul> <li>Arguments</li> <li>Positional Arguments</li> <li>Keyword Arguments</li> <li>Default Arguments</li> <li>Call by Value</li> </ul> <p>Lesson-4.3</p> <ul> <li>Scope</li> <li>Local</li> <li>Global</li> <li>Namespaces</li> <li>locals</li> <li>globals</li> <li>Scope and Namespaces</li> </ul> <p>Lesson-4.4</p> <ul> <li>Recursion</li> <li>Caution in Recursion</li> </ul>"},{"location":"#chapter-5-lists-and-tuples","title":"Chapter-5: Lists and Tuples","text":"<p>Lesson-5.1</p> <ul> <li>Lists</li> <li>Introduction</li> <li>Iterating through Lists</li> <li>Growing a List</li> <li>Operations on Lists</li> <li>Useful Functions</li> </ul> <p>Lesson-5.2</p> <ul> <li>Lists</li> <li>Mutability</li> <li>Call by Reference</li> </ul> <p>Lesson-5.3</p> <ul> <li>Lists</li> <li>Simulating an IPL Innings</li> </ul> <p>Lesson-5.4</p> <ul> <li>Lists</li> <li>List Methods</li> <li>Stack and Queue</li> <li>Strings and Lists<ul> <li><code>split</code></li> <li><code>join</code></li> </ul> </li> </ul> <p>Lesson-5.5</p> <ul> <li>Lists</li> <li>Nested Lists</li> <li>Matrices</li> <li>Shallow and Deep Copy</li> </ul> <p>Lesson-5.6</p> <ul> <li>Tuples</li> <li>Introduction</li> <li>More on Tuples</li> <li>Lists and Tuples</li> <li>Packing and Unpacking</li> </ul>"},{"location":"#chapter-6-dictionaries-and-sets","title":"Chapter-6: Dictionaries and Sets","text":"<p>Lesson-6.1</p> <ul> <li>Dictionaries </li> <li>Introduction</li> <li>Examples</li> <li>Iterating over Dictionaries</li> <li>Growing a Dictionary</li> <li>Mutability</li> </ul> <p>Lesson-6.2</p> <ul> <li>Text Processing</li> <li>Number of Sentences</li> <li>Number of Words</li> <li>Number of Unique Words</li> <li>Frequent Words</li> </ul> <p>Lesson-6.3</p> <ul> <li>Dictionaries</li> <li>Pangrams and Dictionaries</li> <li>Dictionary Methods</li> </ul> <p>Lesson-6.4</p> <ul> <li>Dictionaries in Action: LMS</li> <li>Assignment Model</li> <li>Submission Model</li> <li>Grader</li> </ul> <p>Lesson-6.5</p> <ul> <li>Sets</li> <li>Introduction</li> <li>Iterating over Sets</li> <li>Growing Sets</li> <li>Set Operations</li> </ul>"},{"location":"#chapter-7-file-handling","title":"Chapter-7: File Handling","text":"<p>Lesson-7.1</p> <ul> <li>File Handling</li> <li>Why Files</li> <li>File Handling</li> </ul> <p>Lesson-7.2</p> <ul> <li>File Handling</li> <li>Creating a file in Replit</li> <li>Opening and Reading from a file</li> <li>Writing to a file</li> </ul> <p>Lesson-7.3</p> <ul> <li>File Handling</li> <li>File object analogy</li> <li>Mode</li> </ul> <p>Lesson-7.4</p> <ul> <li>File Handling</li> <li>File methods<ul> <li><code>read</code></li> <li><code>readline</code></li> <li><code>readlines</code></li> <li><code>write</code></li> <li><code>writelines</code></li> </ul> </li> </ul> <p>Lesson-7.5</p> <ul> <li>File Handling</li> <li>CSV files<ul> <li>Reading a CSV file</li> <li>Files to Collections</li> </ul> </li> </ul>"},{"location":"#chapter-8-object-oriented-programming","title":"Chapter-8: Object Oriented Programming","text":"<p>Lesson-8.1</p> <ul> <li>Objects and Classes</li> <li>OOP in Python: an example</li> </ul> <p>Lesson-8.2</p> <ul> <li>Classes and Objects</li> <li><code>self</code></li> <li>Class Attributes vs Object Attributes</li> </ul> <p>Lesson-8.3</p> <ul> <li>Inheritance</li> <li>Concrete Example</li> <li>Parent-child relationship</li> <li>Method Overriding</li> </ul> <p>Lesson-8.4</p> <ul> <li>Vector: Mathematical Preliminaries</li> <li>Vector: Specification</li> <li>Vector: Definition</li> <li>Collection of Vectors</li> </ul>"},{"location":"chapter-0/lesson-0/","title":"Lesson-0","text":""},{"location":"chapter-0/lesson-0/#lesson-0","title":"Lesson-0","text":""},{"location":"chapter-0/lesson-0/#what-is-python","title":"What is Python?","text":"<p>To answer this question, we need to first ask What is a programming language? A programming language is essentially a language in which you can tell your computer what to do. You will understand what that means as start programming. Every programming language has its own strengths and purposes. Python is a general-purpose programming language that can be used for a wide variety of purposes including but not limited to data science, automation, machine learning and  software and web development. A typical python program to find the sum of the first 100 numbers looks like this:</p> <pre><code>sum = 0\nfor number in range(1, 101):\n  sum += number\nprint(sum)\n</code></pre> <p>Do not worry too much about how the code works right now, we'll get into that over the course of the book. But now let's address a question you might have right now - why do we need to complicate things with programming languages to tell the computer what to do when we have simple applications like calculators that can do the same? Let's do a boring experiment: Let's add all the numbers from \\(1\\) through \\(100\\) on a calculator. How long did it take you? Now let's run the following program: </p> <p>How long did this code take you? Blazingly fast, isn't it? That's what coding enables you to do - Create ingenious solutions to problems. Programming also enables you to create applications. Applications like calculator that are designed for use by non-coders are created using code. Consider the following simple application. It takes two numbers as input and prints out their sum.</p> <p>The codes for these programs are in <code>main.py</code> files which you can view by pressing the   Show files     button. Come back and go through the code when you have learned some python.</p>"},{"location":"chapter-0/lesson-0/#why-learn-python","title":"Why learn Python?","text":"<p>The strongest reason is utility. Python powers a large number of applications and is used by companies like Google, Netflix, Dropbox, Quora. A closely related reason is popularity. If a language is popular in the developer community, then there must be something good about it. In a 2022 survey conducted by the company StackOverflow, Python was rated as the second most wanted language.</p> <p></p> <p>Around 66% of the 65,000 developers who responded to the survey are currently developing with Python and have expressed interest in continuing to develop with it. Another strong reason to learn Python is that it lets us create beautiful things such as this animation<sup>1</sup>:</p> <p></p> <p>Being able to create something like this is the end goal of this course. Musicians create music; musical instruments are their tools. Painters create paintings; the brush and the canvas are their tools. Coders create software; programming languages are their tools. Python is one of the most versatile and accessible languages out there. Python was designed to be human readable and easy while also being very powerful. This quality makes python the perfect first programming language. We will start from the basics and systematically cover the important aspects of the language. </p> <p>How easy is Python?</p> <p>Python has a vast collection of libraries that makes it easy to implement complex tasks. This is well described by this cheeky comic<sup>2</sup> that pops up when you enter <code>import antigravity</code> in IDLE.</p> <p></p>"},{"location":"chapter-0/lesson-0/#lessons","title":"Lessons","text":""},{"location":"chapter-0/lesson-0/#organization","title":"Organization","text":"<p>This index is organized as a sequence of lessons. Lessons will be numbered as <code>&lt;chapter&gt;.&lt;lesson&gt;</code>. Each chapter will have about four lessons. These lessons are best read in the sequence in which they appear, starting from chapter-1 and going all the way up to chapter-12. If you are already familiar with Python, then have a look at the Table of Contents in the home page and jump into the lesson that seems least familiar.</p> <p>Each chapter introduces one important programming concept in Python. This will be that chapter's title. This doesn't mean that all the lessons in the chapter will focus on only that particular concept. For example, chapter-2 introduces the idea of conditionals, but built-in functions and Python's standard libraries also feature in the same week.</p> <p>The outline of the book is as follows:</p> <ul> <li> <p>Chapter-1: Introduction to Python</p> </li> <li> <p>Chapter-2: Conditionals</p> </li> <li> <p>Chapter-3: Loops</p> </li> <li> <p>Chapter-4: Functions</p> </li> <li> <p>Chapter-5: Lists and Tuples</p> </li> <li> <p>Chapter-6: Sets and dictionaries</p> </li> <li> <p>Chapter-7: File handling</p> </li> <li> <p>Chapter-8: Object Oriented Programming</p> </li> </ul>"},{"location":"chapter-0/lesson-0/#how-to-read-these-lessons","title":"How to read these lessons?","text":"<ul> <li>Do not trust any piece of code blindly.</li> <li>Execute the code and observe the output.</li> <li>Think about the output. </li> <li>Verify if the explanation given in text matches your observations.</li> </ul> <p>Programming courses are among the few courses where the learner has an upper hand over instructors. No one can trick you. Code does not lie. All that is demanded of you is to make an effort to execute every snippet of code that you see in these lessons.</p>"},{"location":"chapter-0/lesson-0/#python-version","title":"Python Version","text":"<p>We will be using Python-3.8 or higher throughout these lessons. If some of you are already familiar with Python and are used to Python-2, it is strongly recommended that you shift to Python-3. This is not an arbitrary choice as Python-2 has reached the end of its life.</p>"},{"location":"chapter-0/lesson-0/#setting-up-replit","title":"Setting up Replit","text":"<p>Replit is an online environment where we can write code. It is an ideal place to learn programming and we will be using it extensively in this course. Head to replit.com and sign up using your Online Degree account. Replit provides an excellent tutorial to get you started.</p>"},{"location":"chapter-0/lesson-0/#installing-python-on-your-system","title":"Installing Python on your System","text":"<p>However, if you wish to use Python on your system, you can install it from here. You can refer to this guide to get a step-by-step process of installing Python. Having Python on your system will be useful in the subjects that you'll emcounter in the Diploma level.</p>"},{"location":"chapter-0/lesson-0/#history","title":"History","text":"<p>Python first appeared on the programming landscape 30 years ago, in February 1991. It was created as a hobby project by a Dutch programmer, Guido van Rossum. He served as the benevolent dictator for life of Python\u2019s development until 2018, when he stepped down from the post.</p> <p> </p> <p>Guido Van Rossum at the Dropbox Headquarters in 2014<sup>3</sup></p> <p>A popular question that gets asked often is how the language got its name. This is the answer from the official Python documentation:</p> <p>When he began implementing Python, Guido van Rossum was also reading the published scripts from \u201cMonty Python\u2019s Flying Circus\u201d, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python.</p> <p>Python is 30 years old. Programmers who boarded the Python-bus 30 years back lovingly talk of it as though it were a friend. This is not an exaggeration! This is a language that has been built by people like you and me, and is being used by thousands of people around the globe. Let us jump in with an open mind and see what it has to offer!</p>"},{"location":"chapter-0/lesson-0/#explore","title":"Explore","text":"<ol> <li>Check out the website of the Python Software Foundation and get to know more about the organization behind Python.</li> <li>Have a look at this interesting interview of Guido Van Rossum. This is a blog maintained by Dropbox. Another trivia: Guido worked at Dropbox for six and a half years. </li> <li>Try to watch documentaries and interviews on the web where Guido talks about how Python came into existence. It is always good to know about some non-technical aspects of the language, such as its history and something about the people who were behind its development. It gives a humanistic flavor to technology. We often forget that a lot of software is written by humans, for humans.</li> <li>In the next few weeks to come, StackOverflow might become the most visited website by most of you. Some of you might be familiar with it, but for the others, StackOverflow is a question-answer forum for programming related questions. It is extremely popular not just among beginners but even experienced developers. Do check it out, but use it wisely. Refrain from using it to get answers to assignment questions; you won't learn anything that way.</li> <li>You can also look into the official documentation on the python website.</li> </ol> <ol> <li> <p>Thanks to Manim Community for the source code. The code that was used to render this animation can be found here.\u00a0\u21a9</p> </li> <li> <p>Credit to xkcd.com for the comic\u00a0\u21a9</p> </li> <li> <p>Image-Source: Wikipedia \u21a9</p> </li> </ol>"},{"location":"chapter-1/lesson-1.1/","title":"Lesson-1.1","text":""},{"location":"chapter-1/lesson-1.1/#lesson-11","title":"Lesson-1.1","text":""},{"location":"chapter-1/lesson-1.1/#python-shell-replit-console","title":"Python shell | Replit Console","text":"<p>In this lesson, we will be working with the Python interpreter in Interactive Mode. It is also often called the Python shell. It is a tool that lets us execute individual lines of code and see the output right away. We will drop the phrase \"interactive mode\" and just refer to it as the interpreter. Have a look at the official Python documentation for more details about the Python Interpreter . If you have Python installed on your system, then the Python shell will look like this:</p> <p></p> <p>In Replit, this corresponds to the console screen on the right of the repl. This will be our playground for quite sometime:</p> <p></p>"},{"location":"chapter-1/lesson-1.1/#prompts","title":"Prompts","text":"<p>The orange symbol that is displayed above is called a prompt. Its role is similar to that of the blinking cursor while editing documents. It is an invitation to type code. Code that is typed at the prompt is executed by the interpreter. In these lessons, we will use the following symbol to refer to the prompt: <code>&gt;&gt;&gt;</code>.</p> <p>We are all set to write our first line of code:</p> <pre><code>&gt;&gt;&gt; print('Hello World!')\nHello World!\n</code></pre> <p>Fire up a repl and type the code in the console. You will be getting the output on the next line.</p>"},{"location":"chapter-1/lesson-1.1/#output","title":"Output","text":"<p>Let us take a closer look at the first line of code that we wrote. <code>print()</code> is called a built-in function in Python. A function is an object that accepts inputs and returns outputs. The term built-in refers to the fact that this function is something that is readily provided by Python for our use.</p> <pre><code>&gt;&gt;&gt; print('Hello World!')\nHello World!\n&gt;&gt;&gt; print(\"Hello World!\")\nHello World!\n</code></pre> <p>The sentence enclosed by the parentheses of the <code>print()</code> function is called a string. A string is a sequence of characters enclosed in quotes. Strings can either be in single quotes or double quotes. However, a single quote can't be matched against a double quote to enclose a string. We have used single quotes in line 1 and double quotes in line 3. Both lines give identical outputs. The ability to use both single quotes and double quotes comes in handy in situations like this:</p> <p> </p> <p>Print a string that has an apostrophe in it:</p> <pre><code>&gt;&gt;&gt; print(\"India's capital is New Delhi.\")\n</code></pre> <p>Run the code given above and observe the output. <code>print()</code> can also be used to print numbers:</p> <pre><code>&gt;&gt;&gt; print(1)\n1\n&gt;&gt;&gt; print(2.0)\n2.0\n</code></pre> <p>Multiple items can be printed on the same line in the following way:</p> <pre><code>&gt;&gt;&gt; print(1, 2)\n1 2\n&gt;&gt;&gt; print('online', 'degree', 'program')\nonline degree program\n</code></pre> <p>Notice the presence of a space between successive elements? <code>print</code> automatically seperates multiple values with a delimiter, which is space by default.</p> <p>If the <code>print</code> command is called without passing any input to it, then it prints a blank line:</p> <pre><code>&gt;&gt;&gt; print()\n\n&gt;&gt;&gt;\n</code></pre> <p>What happens if we just use type <code>print</code> without having the parentheses?</p> <pre><code>&gt;&gt;&gt; print\n&lt;built-in function print&gt;\n</code></pre> <p>We don't get an error. Instead, the message is that <code>print</code> is a built-in function. But when you try the following code:</p> <pre><code>&gt;&gt;&gt; print 'Hello World!'\n  File \"&lt;stdin&gt;\", line 1\n    print 'Hello World!'\n          ^\nSyntaxError: Missing parentheses in call to 'print'. Did you mean print('Hello World!')?\n</code></pre> <p>The interpreter hits back with a <code>SyntaxError</code>. Like human languages, programming languages have their own syntaxes that have to be followed to convey your commands to the computer. Programming language syntaxes, however, are far more strict and have to be followed exactly in order to run your code. Parantheses are used to execute and pass values (called arguments in programming jargon) to functions like <code>print</code> . Note the lack of parentheses in the above snippet which is also pointed out by the handy error message. We will learn the syntax for various concepts in python in the upcoming lessons.</p>"},{"location":"chapter-1/lesson-1.1/#emojis","title":"Emojis","text":"<p>Before we jump into the serious stuff, let us try and print some emojis!</p> <pre><code>&gt;&gt;&gt; print('\\N{smiling face with smiling eyes}')\n\ud83d\ude0a\n&gt;&gt;&gt; print('\\N{grinning face}')\n\ud83d\ude00\n&gt;&gt;&gt; print('\\N{smiling face with halo}')\n\ud83d\ude07\n&gt;&gt;&gt; print('\\N{thinking face}')\n\ud83e\udd14\n</code></pre> <p>Try this out in an interpreter of your choice! A full list of emojis can be found here.</p>"},{"location":"chapter-1/lesson-1.1/#literals-and-variables","title":"Literals and Variables","text":"<p>Strings like <code>'Hello World!'</code> and numbers like <code>1</code>, <code>2.0</code> are called literals in Python. Formally, a literal is something that describes a constant value. Variables are containers that are used to store values. Variables in Python are defined in the following way:</p> <pre><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; print(x)\n1\n&gt;&gt;&gt; y = 'a string'\n&gt;&gt;&gt; print(y)\na string\n&gt;&gt;&gt; foo_bar = 123.456\n&gt;&gt;&gt; print(foo_bar)\n123.456\n</code></pre> <p><code>=</code> is called the assignment operator. Whenever the assignment operator is present in a statement, it is used for one of the following purposes:</p> <ul> <li>define a new variable</li> <li>update an existing variable</li> </ul> <pre><code>&gt;&gt;&gt; x = 1         # define a new variable\n&gt;&gt;&gt; x = x + 1     # update an existing variable\n&gt;&gt;&gt; print(x)\n2\n</code></pre> <p>The assignment operator is evaluated from right to left. That is, the expression to the right of the assignment operator is evaluated first. This result is then assigned to the variable on the left. Variables will be taken up in greater detail in the lessons of the second chapter.</p>"},{"location":"chapter-1/lesson-1.1/#basic-data-types-type","title":"Basic Data Types | type()","text":"<p>We will be looking at the following basic data types:</p> <ul> <li>Integer</li> <li>Float</li> <li>String</li> <li>Boolean</li> </ul>"},{"location":"chapter-1/lesson-1.1/#integer","title":"Integer","text":"<p>The <code>int</code> type represents integers. Python provides a command called <code>type</code> to determine the type of an object:</p> <pre><code>&gt;&gt;&gt; print(1)\n1\n&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n</code></pre>"},{"location":"chapter-1/lesson-1.1/#float","title":"Float","text":"<p>The <code>float</code> type represents real numbers:</p> <pre><code>&gt;&gt;&gt; print(1.0)\n1.0\n&gt;&gt;&gt; type(1.0)\n&lt;class 'float'&gt;\n</code></pre> <p>The following is also a valid float literal:</p> <pre><code>&gt;&gt;&gt; print(1.)\n1.0\n</code></pre> <p><code>1.</code> and <code>1.0</code> are one and the same literal.</p>"},{"location":"chapter-1/lesson-1.1/#string","title":"String","text":"<p>The <code>str</code> type represents strings:</p> <pre><code>&gt;&gt;&gt; print('one')\none\n&gt;&gt;&gt; type(\"one\")\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"chapter-1/lesson-1.1/#boolean","title":"Boolean","text":"<p>The <code>bool</code> type represents boolean values:</p> <pre><code>&gt;&gt;&gt; print(True)\nTrue\n&gt;&gt;&gt; type(False)\n&lt;class 'bool'&gt;\n</code></pre> <p>Please note that <code>bool</code> values are case sensitive. That is, <code>true</code> and <code>false</code> are not <code>bool</code> values.</p>"},{"location":"chapter-1/lesson-1.1/#comments","title":"Comments","text":"<p>A comment is a line of text that is not executed by the interpreter. Comments begin with the <code>#</code> symbol. The following are comments:</p> <pre><code>&gt;&gt;&gt; # This is a comment\n&gt;&gt;&gt; # print(1)\n&gt;&gt;&gt; \n</code></pre> <p>As line-2 is a comment, <code>1</code> is not printed in the next line. Comments can also come at the end of a line of code:</p> <pre><code>&gt;&gt;&gt; print(1) # This line is printing the value 1\n1\n</code></pre> <p>Adding comments is one of the ways to make code more readable. Its use will become clear in subsequent chapters.</p>"},{"location":"chapter-1/lesson-1.2/","title":"Lesson-1.2","text":""},{"location":"chapter-1/lesson-1.2/#lesson-12","title":"Lesson-1.2","text":""},{"location":"chapter-1/lesson-1.2/#operators","title":"Operators","text":""},{"location":"chapter-1/lesson-1.2/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>The anatomy of an operation is given below:</p> <p></p> <p>The following table gives the symbols for arithmetic operators and the operations that they correspond to:</p> Operator Operation + Addition - Subtraction * Multiplication / Division // Floor division % Modulus ** Exponentiation <p>All the operators in the above table are binary, i.e., they operate on two operands. Let us now take a look at each operator:</p> <pre><code>&gt;&gt;&gt; 10 + 5\n15\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 10 * 5\n50\n&gt;&gt;&gt; 10 / 5\n2.0\n&gt;&gt;&gt; 10 // 5\n2\n&gt;&gt;&gt; 10 % 5\n0\n&gt;&gt;&gt; 10 ** 5\n100000\n</code></pre> <p>The last three operators might be new. In more familiar terms, these are the mathematical operations that they correspond to:</p> <ul> <li><code>//</code> is called the floor division operator. <code>x // y</code> gives the quotient when <code>x</code> is divided by <code>y</code>. For example, <code>8 // 3</code> is <code>2</code>.</li> <li><code>%</code> is called the modulus operator. <code>x % y</code> gives the remainder when <code>x</code> is divided by <code>y</code>. For example, <code>10 % 3</code> is <code>1</code>. </li> <li><code>**</code> is called the exponentiation operator. <code>x ** y</code> returns \\(x^y\\).</li> </ul> <p><code>/</code> and <code>//</code> are two different operators. <code>/</code> gives the complete result of division, while <code>//</code>  returns the quotient. For example, <code>5 / 2</code> results in <code>2.5</code> while <code>5 // 2</code> gives <code>2</code>. There are two more arithmetic operators of interest to us, unary plus and unary minus. These are the <code>+</code> and  <code>-</code> signs. Unlike the operators that we have seen so far, these two are unary operators, i.e., they operate on one operand. For example:</p> <pre><code>&gt;&gt;&gt; - 2\n-2\n&gt;&gt;&gt; + 2\n2\n</code></pre> <p>It is important to note that the symbols for plus and minus operators are the same as the ones for addition and subtraction. The context determines the nature of the operator:</p> <pre><code>&gt;&gt;&gt; - 1    # unary minus\n-1\n&gt;&gt;&gt; 1 - 1  # subtraction operator\n</code></pre> <p>Sometimes both of them could come together in the same expression:</p> <pre><code>&gt;&gt;&gt; 1 - - 1 \n2\n&gt;&gt;&gt; # The minus on the left is subtraction\n&gt;&gt;&gt; # The minus on the right is unary minus\n</code></pre> <p>In all the operations that we have seen so far, the operands have been literals. In general, the operands can also be variables:</p> <pre><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = x * 5\n&gt;&gt;&gt; print(x, y)\n1 5\n</code></pre>"},{"location":"chapter-1/lesson-1.2/#relational-operators","title":"Relational Operators","text":"<p>The following table gives the symbols for relational operators and the operations that they correspond to:</p> Operator Operation &gt; greater than &lt; less than &gt;= greater than or equal to &lt;= less than or equal to == double equal to != not equal to <p>All the operators in the above table are binary. Let us now take a look at each of them:</p> <pre><code>&gt;&gt;&gt; 10 &gt; 5\nTrue\n&gt;&gt;&gt; 10 &lt; 5\nFalse\n&gt;&gt;&gt; 10 &gt;= 5\nTrue\n&gt;&gt;&gt; 10 &lt;= 5\nFalse\n&gt;&gt;&gt; 10 == 5\nFalse\n&gt;&gt;&gt; 10 != 5\nTrue\n</code></pre> <p>Relational operators are also called comparison operators. The result of any comparison operation is a boolean value: <code>True</code> or <code>False</code>. The result of a comparison operation can be assigned to a variable:</p> <pre><code>&gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 15\n&gt;&gt;&gt; z = y &gt; x\n&gt;&gt;&gt; print(z)\nTrue\n</code></pre> <p>The <code>==</code> symbol corresponds to the equality operator and should not be confused with <code>=</code>, the assignment operator.</p>"},{"location":"chapter-1/lesson-1.2/#logical-operators","title":"Logical Operators","text":"<p>The following table gives the logical operators and the operations that they correspond to:</p> Operator Operation not negation and logical conjunction or logical disjunction <p><code>and</code> and <code>or</code> are binary operators; <code>not</code> is a unary operator. Let us now take a look at each of them:</p> <pre><code>&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; True or False\nTrue\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; y = not x\n&gt;&gt;&gt; print(y)\nTrue\n</code></pre> <p>The use of parenthesis after <code>not</code> is optional. For example:</p> <pre><code>&gt;&gt;&gt; x = True\n&gt;&gt;&gt; not x\nFalse\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; not(x)\nTrue\n</code></pre> <p>Convention</p> <p>Consider the following lines of code:</p> <pre><code>&gt;&gt;&gt; print(1 + 2)\n3\n&gt;&gt;&gt; print(1+2)\n3\n</code></pre> <p>Both lines 1 and 3 give the same output. Line-1 has a space before and after the <code>+</code> operator, while line-3 doesn't. Both ways are syntactically correct. In this course, we will be following the first convention: there is always a space separating the operator from the operands. This is also true for the <code>=</code> operator.</p> <pre><code>&gt;&gt;&gt; x = 2 # We will follow this\n&gt;&gt;&gt; x=2   # We will NOT follow this\n# But both conventions are valid\n</code></pre>"},{"location":"chapter-1/lesson-1.2/#operator-chaining","title":"Operator Chaining","text":"<p>Python supports chaining relational operators. This enables you to evaluate chains of comparison without having to use logical operators.  </p><pre><code>&gt;&gt;&gt; 10 &lt; 11 &lt;= 12\nTrue\n# is the same as\n&gt;&gt;&gt; 10 &lt; 11 and 11 &lt;= 12\nTrue\n</code></pre>"},{"location":"chapter-1/lesson-1.2/#expressions","title":"Expressions","text":"<p>An expression is some combination of literals, variables and operators. For example, the following are expressions:</p> <ul> <li><code>1 + 4 / 4 ** 0</code> </li> <li><code>x / y + z * 2.0</code></li> <li><code>3 &gt; 4 and 1 &lt; 10</code></li> <li><code>not True and False</code></li> </ul> <p>Each expression evaluates to some value. This value has a type. In the above examples, the first two expressions result in a <code>float</code>, while the next two expressions result in a <code>bool</code>. In the next few sections, we shall study two types of expressions:</p> <ul> <li>Arithmetic: an expression whose type is either <code>int</code> or <code>float</code></li> <li>Boolean: an expression whose type is <code>bool</code></li> </ul>"},{"location":"chapter-1/lesson-1.2/#types-of-expressions","title":"Types of Expressions","text":""},{"location":"chapter-1/lesson-1.2/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<p>Let us now look at the <code>type</code> of simple arithmetic operations. In mathematics, the result of adding two integers is another integer. Is this true in the case of Python? First, let us execute the following statement in the interpreter and see what we get:</p> <pre><code>&gt;&gt;&gt; 1 + 2\n3\n</code></pre> <p>The way to check the type of this expression is to use the <code>type()</code> function. For example, we have:</p> <pre><code>&gt;&gt;&gt; 1 + 2\n3\n&gt;&gt;&gt; type(1 + 2)\n&lt;class 'int'&gt;\n</code></pre> <p>So far the interpreter's behaviour conforms to our intuition. Let us now change this code slightly:</p> <pre><code>&gt;&gt;&gt; 1.0 + 2\n3.0\n&gt;&gt;&gt; type(1.0 + 2)\n&lt;class 'float'&gt;\n</code></pre> <p>We see that the result is <code>3.0</code> which is of type <code>float</code>. The conclusion is that <code>float</code> is more dominant than <code>int</code> as far as the addition operation is concerned. What about other operations? Let us check with the help of the following examples:</p> <pre><code>&gt;&gt;&gt; type(7.0 * 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 / 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 // 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 ** 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 % 5)\n&lt;class 'float'&gt;\n</code></pre> <p>All the operations result in a <code>float</code>. From this we see that <code>float</code> is more dominant than <code>int</code>, irrespective of the operator involved.</p>"},{"location":"chapter-1/lesson-1.2/#boolean-expressions","title":"Boolean Expressions","text":"<p>Expressions that involve a relational operator will result in a <code>bool</code>. For example:</p> <pre><code>&gt;&gt;&gt; 2 &gt; 1\nTrue\n&gt;&gt;&gt; type(2 &gt; 1)\n&lt;class 'bool'&gt;\n</code></pre> <p>Expressions that involve logical operators will naturally result in a <code>bool</code>. For example:</p> <pre><code>&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; type(True and False)\n&lt;class 'bool'&gt;\n</code></pre> <p>One way to analyze the outcome of boolean expressions that involve variables is to exhaustively list down the different combinations of values that variables can take and evaluate the expression for each such combination. For example, assume that X and Y are two boolean variables. Now, consider the following expression:</p> <pre><code>&gt;&gt;&gt; X or Y\n</code></pre> <p>We can take the help of a concept called truth table to analyze the outcomes:</p> X Y X or Y True True True True False True False True True False False False"},{"location":"chapter-1/lesson-1.3/","title":"Lesson-1.3","text":""},{"location":"chapter-1/lesson-1.3/#lesson-13","title":"Lesson-1.3","text":""},{"location":"chapter-1/lesson-1.3/#arithmetic-expressions","title":"Arithmetic Expressions","text":""},{"location":"chapter-1/lesson-1.3/#precedence","title":"Precedence","text":"<p>Let us start looking at arithmetic expressions that involve multiple operators:</p> <pre><code>&gt;&gt;&gt; 4 // 2 - 1\n1\n</code></pre> <p>We can interpret this statement in two ways:</p> <ul> <li><code>(4 // 2) - 1 = 2 - 1 = 1</code></li> <li><code>4 // (2 - 1) = 4 // 1 = 4</code></li> </ul> <p>Clearly, we see that the interpreter is following the first way. When an expression has different operators, the interpreter has to make a decision about the way the expression is to be parenthesized, i.e., which operator takes precedence over the others. From the above example, we see that the floor division operator (<code>//</code>) has greater precedence than the subtraction operator (<code>-</code>).</p> <p>In general, the following table describes the precedence rules for operators. Those with higher precedence come at the top of the table. Operators in a given cell have the same precedence. For example, <code>+</code> and <code>-</code> have same precedence.</p> <p></p> <p>Let us take another example:</p> <pre><code>&gt;&gt;&gt; 3 ** 2 * 4 - 4\n32\n</code></pre> <p>Going by the precedence rules, we apply the parenthesis in the following sequence:</p> <ol> <li><code>(3 ** 2) * 4 - 4</code></li> <li><code>((3 ** 2) * 4) - 4</code></li> </ol> <p>This is evaluated as: <code>((3 ** 2) * 4) - 4 = (9 * 4) - 4 = 36 - 4 = 32</code> </p>"},{"location":"chapter-1/lesson-1.3/#order","title":"Order","text":"<p>Consider the following example:</p> <pre><code>&gt;&gt;&gt; 3 - 2 + 1\n2\n</code></pre> <p>We can interpret this statement in two ways:</p> <ul> <li><code>(3 - 2) + 1 = 1 + 1 = 2</code></li> <li><code>3 - (2 + 1) = 3 - 3 = 0</code>. </li> </ul> <p>The interpreter is following the first way. Does this mean that subtraction has greater precedence than addition? No, we just saw that they have the same precedence! We have to be careful here. Python evaluates expressions from left to right. There are two exceptions to this rule, the <code>**</code> and <code>=</code> operator, both of which are evaluated from right to left. We shall return to this in a while.</p> <p>Now for another example. Consider the following expression:</p> <pre><code>&gt;&gt;&gt; 4 - 3 - 1\n0\n</code></pre> <p>The two ways of doing this are:</p> <ul> <li><code>(4 - 3) - 1 = 1 - 1 = 0</code></li> <li><code>4 - (3 - 1) = 4 - 2 = 2</code></li> </ul> <p>The first way is the one followed by the interpreter. Going back to the evaluation order followed by Python, we see that this expression is evaluated from left to right.</p> <p>Let us take another example:</p> <pre><code>&gt;&gt;&gt; 8 % 4 % 2\n0\n</code></pre> <p>Run the following code in the interpreter. Which of the following parenthesizations matches the expression given above? This is left as an exercise for you to try out.</p> <pre><code>&gt;&gt;&gt; (8 % 4) % 2\n&gt;&gt;&gt; 8 % (4 % 2)\n</code></pre> <p>Finally, <code>**</code> is a unique operator in this regard:</p> <pre><code>&gt;&gt;&gt; 2 ** 3 ** 0\n2\n</code></pre> <p>The two ways of doing this are:</p> <ul> <li><code>(2 ** 3) ** 0</code></li> <li><code>2 ** (3 ** 0)</code></li> </ul> <p>The interpreter is following the second way, i.e., the statement is being executed from right to left. This kind of execution happens only in the case of the exponentiation operator and the assignment operator.</p>"},{"location":"chapter-1/lesson-1.3/#boolean-expressions","title":"Boolean expressions","text":"<p>The simplest example of an expression that results in a boolean value is given below:</p> <pre><code>&gt;&gt;&gt; 1 &gt; 0\nTrue\n&gt;&gt;&gt; type(1 &gt; 0)\n&lt;class 'bool'&gt;\n</code></pre> <p>The following expression conveys the fact that <code>3.14</code> lies between 3 and 4:</p> <pre><code>&gt;&gt;&gt; 3 &lt; 3.14 and 4 &gt; 3.14\nTrue\n</code></pre> <p>This can also be written in the following manner:</p> <pre><code>&gt;&gt;&gt; 3 &lt; 3.14 &lt; 4\nTrue\n</code></pre> <p>Let us add some boolean literals into the mix:</p> <pre><code>&gt;&gt;&gt; 10 &gt; 20 or True\nTrue\n</code></pre> <p>As an exercise, try the following:</p> <pre><code>&gt;&gt;&gt; False or False or False or False or True\n</code></pre>"},{"location":"chapter-1/lesson-1.3/#precedence-and-order","title":"Precedence and Order","text":"<p>Similar to arithmetic operators, logical operators also have precedence. Boolean expressions are also going to evaluated from left to right:</p> <p></p> <p>To see this rule in action, consider the following example:</p> <pre><code>&gt;&gt;&gt; not True and False\nFalse\n</code></pre> <p>There are two different parenthesizations:</p> <ul> <li><code>not(True) and False = False and False = False</code></li> <li><code>not(True and False) = not(False) = True</code></li> </ul> <p>Clearly, the interpreter is following the first parenthesization. This is in accordance with the precedence rule for logical operators. The evaluation order is from left to right. But we will return to this in more detail in the section on short circuit evaluation. Another example, this time with <code>and</code> and <code>or</code>:</p> <pre><code>&gt;&gt;&gt; True or False and False\nTrue\n</code></pre> <p>There are two different parenthesizations:</p> <ul> <li><code>(True or False) and False = True and False = False</code></li> <li><code>True or (False and False) = True or False = True</code></li> </ul> <p>According to the precedence rules, <code>and</code> has greater precedence than <code>or</code>. So, the second way is the one followed by Python.</p>"},{"location":"chapter-1/lesson-1.3/#beware-of-float","title":"Beware of <code>float</code>!","text":"<p>Execute the following expression in the interpreter:</p> <pre><code>&gt;&gt;&gt; 10.00000000000000000000001 &gt; 10\nFalse\n</code></pre> <p>This seems surprising! <code>10.00000000000000000000001 &gt; 10</code> is a perfectly valid mathematical statement that evaluates to <code>True</code>. The reason this returns <code>False</code> in Python has to do with the way floating point numbers are represented. Python, and programming languages in general, do not support arbitrary precision for representing real numbers. When the number cannot be represented exactly, an approximate value is returned. As a result of this behaviour, we should be careful when using <code>float</code> values in expressions that involve comparisons. Another example:</p> <pre><code>&gt;&gt;&gt; 0.1 ** 100 == 0.0\nFalse\n&gt;&gt;&gt; 0.1 ** 1000 == 0.0\nTrue\n</code></pre> <p>The above expression presents a typical case of approximation when dealing with <code>float</code>. The number <code>0.1 ** 1000</code> is extremely small. So, the interpreter is going to represent that as 0. One more example follows:</p> <pre><code>&gt;&gt;&gt; 0.1 * 3 == 0.3\nFalse\n</code></pre> <p>Let us see what is happening here by starting with the expression to the left of the <code>==</code> operator:</p> <pre><code>&gt;&gt;&gt; 0.1 * 3\n0.30000000000000004\n</code></pre> <p>Note: The following explanation can be skipped.</p> <p>The problem is with the way <code>0.1</code> is represented in binary - it has a non-terminating, recurring sequence of bits after the decimal point. As the computer uses a finite number of bits to represent data, this sequence will be truncated at some stage. This results in an approximate representation of <code>0.1</code>. For a more detailed explanation, refer to this resource.</p>"},{"location":"chapter-1/lesson-1.3/#short-circuit-evaluation","title":"Short Circuit Evaluation","text":"<p>Now, we come to an important feature in Python. Execute the following expression in the interpreter:</p> <pre><code>&gt;&gt;&gt; 1 / 0\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n</code></pre> <p>Division by zero is not allowed, and the interpreter promptly hits back with an error message. This is not surprising. But what is surprising is the following statement:</p> <pre><code>&gt;&gt;&gt; True or (1 / 0)\nTrue\n</code></pre> <p>No error message! How do we explain this behaviour?</p> <p>The expression is evaluated from left to right. The operator is <code>or</code>. Since the operand on the left is <code>True</code>, the whole expression will evaluate to <code>True</code> irrespective of the operand on the right. So, the interpreter skips evaluating the operand on the right. This behaviour is called short circuit evaluation.</p> <p>Consider a more complex example:</p> <pre><code>&gt;&gt;&gt; (not((3 &gt; 2) or (5 / 0))) and (10 / 0)\nFalse\n</code></pre> <p>Let us break this down using the diagram given below. The arrows on the left give us an idea of the expression that has to be evaluated first. If we keep following the arrows, the last expression in this image on the bottom-left is the first to be evaluated. By following the arrows on the right, we can see that the two offending expressions - <code>5 / 0</code> and <code>10 / 0</code> - are never evaluated.</p> <p></p>"},{"location":"chapter-1/lesson-1.4/","title":"Lesson-1.4","text":""},{"location":"chapter-1/lesson-1.4/#lesson-14","title":"Lesson-1.4","text":""},{"location":"chapter-1/lesson-1.4/#replit-editor","title":"Replit Editor","text":"<p>We have been using Replit's console to type code so far. We will now move to the editor in Replit. The advantage of using the editor is that code typed here gets automatically saved. Think about it like Google Docs for code. The window to the left of the console is the editor. After typing code, click on the green <code>Run</code> button on the top. The output of the code will appear in the console on the right. We will completely shift to the editor from now. This means dropping the prompt symbol before each line of code.</p> <p></p>"},{"location":"chapter-1/lesson-1.4/#errors","title":"Errors","text":""},{"location":"chapter-1/lesson-1.4/#introduction","title":"Introduction","text":"<p>Enter the following line of code in the editor and run it:</p> <pre><code>print('123)\n</code></pre> <p>This is the output that we get in the console:</p> <pre><code>  File \"main.py\", line 1\n    print('123)\n              ^\nSyntaxError: EOL while scanning string literal\n</code></pre> <p>Lines 1-4 represent an error message. It is the interpreter's way of warning us that there is something wrong with the code. Error messages usually come with some information about the errors which helps us understand what has gone wrong. In this case, we have a <code>SyntaxError</code>, i.e., something is wrong with the syntax. The remaining part of the message gives the details:</p> <ul> <li>EOL stands for End Of Line</li> <li>scanning a string literal</li> </ul> <p>There was an issue with the end of line while scanning a string literal. The <code>^</code> sign points to the place where the error occurred. This acts as a visual aid while trying to trace the error. Going back to the code, the ending quote <code>'</code> is missing. We can now fix it:</p> <pre><code>print('123')\n</code></pre>"},{"location":"chapter-1/lesson-1.4/#debugging","title":"Debugging","text":"<p>Among software professionals, there is an alternative term used for errors in code: bugs. The process of fixing bugs is called debugging. The process usually works as follows:</p> <ol> <li>Run: run the code</li> <li>Detect: the interpreter intimates the coder of the error</li> <li>Understand: the coder has to understand the error message and go back to the code to see what went wrong</li> <li>Update: fix the error by modifying or updating one or more lines of the code</li> </ol> <p>Now, the coder closes the loop by running the code again. If the code throws another error, the whole process repeats.</p> <p></p> <p>Debugging code forms an important part of programming. While working on huge codebases it might take several hours or even days to fix bugs.</p>"},{"location":"chapter-1/lesson-1.4/#exceptions","title":"Exceptions","text":"<p>We now move to a different set of errors. These are no longer syntax errors. Let us take an example:</p> <pre><code>1 / 0\n</code></pre> <p>The output is:</p> <pre><code>Traceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 / 0\nZeroDivisionError: division by zero\n</code></pre> <p>The error message is quite clear here. We are trying to divide by zero and the interpreter is rightly objecting to it. This is called a <code>ZeroDivisionError</code>. But in terms of syntax, there is no error here. Such errors that are detected by the interpreter during the program's execution are called exceptions. We will keep returning to the idea of exceptions in every chapter. Let us look at another exception:</p> <pre><code>1 + 'one'\n</code></pre> <p>The output is:</p> <pre><code>Traceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 + 'one'\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre> <p>The interpreter throws a <code>TypeError</code>. The message accompanying the error is more suggestive: an integer and a string cannot be added, i.e., for the <code>+</code> operator, <code>int</code> and <code>str</code> cannot be the type of the two operands.</p> <p>The next exception that we will frequently encounter is <code>NameError</code>. </p> <pre><code>print('There is no problem with this line')\nprint(x ** 2)\n</code></pre> <p>The output is:</p> <pre><code>There is no problem with this line\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(x ** 2)\nNameError: name 'x' is not defined\n</code></pre> <p>Notice that the first line in the code gets printed correctly. The interpreter starts executing the code from top to bottom. The first line is error free. It is the second line which has a problem. <code>NameError</code> occurs when we try to reference a variable that has not been defined before. We will look at what referencing a variable means in the next chapter.</p>"},{"location":"chapter-1/lesson-1.4/#wrong-code-snippets","title":"Wrong Code Snippets","text":"<p>Wherever we wish to demonstrate examples of incorrect code, we will do it in the following manner:</p> <pre><code>##### Alarm! Wrong code snippet! #####\n\n# Incorrect code will go here #\n\n##### Alarm! Wrong code snippet! #####\n</code></pre>"},{"location":"chapter-1/lesson-1.5/","title":"Lesson-1.5","text":""},{"location":"chapter-1/lesson-1.5/#lesson-15","title":"Lesson-1.5","text":""},{"location":"chapter-1/lesson-1.5/#strings","title":"Strings","text":""},{"location":"chapter-1/lesson-1.5/#quotes-single-double-and-triple","title":"Quotes: single, double and triple","text":"<p>We briefly looked at strings in the first lesson. A string is any sequence of characters enclosed within single or double quotes. Some examples:</p> <pre><code>\"this is a string\"\n'this is also a string'\n'1 + 1 = 2'\n\"!, ?, _, @ are special characters\"\n\"if you need to use apostrophe ('), you can use double quotes\"\n</code></pre> <p>It is a good practice to stick to either single or double quotes when using strings. Interestingly, Python also supports triple quotes <code>'''</code>, especially for multi-line strings, i.e., strings that span multiple lines. Let us say that we want the following lines to be captured in a single string:</p> <pre><code>first line\nsecond line\nthird line\n</code></pre> <p>The following code will throw a <code>SyntaxError</code>:</p> <pre><code>x = 'first line\nsecond line\nthird line'\nprint(x)\n</code></pre> <p>This is where <code>'''</code> comes in:</p> <pre><code>x = '''first line\nsecond line\nthird line'''\nprint(x)\n</code></pre> <p>After executing the above code, head to the console and type <code>x</code>. You will see the following output:</p> <pre><code>'first line\\nsecond line\\nthird line'\n</code></pre> <p>The <code>\\n</code> character that you see above is called a newline character. Head to the section on escape characters in this lesson to know more about them.</p>"},{"location":"chapter-1/lesson-1.5/#length","title":"Length","text":"<p>The length of a string is the number of characters in it. Python provides a built-in function called <code>len</code> to find the length of a string:</p> <pre><code>x = 'good'\nprint(len(x))\n</code></pre> <p>The code given above will give 4 as the output. If you are familiar with other programming languages, such as C, you might be aware of a character data type. Python doesn't have a separate data type for characters. A character in Python is represented by a string of length 1. In the following examples, <code>x</code> and <code>y</code> are strings of length 1.</p> <pre><code>x = 'a'\ny = 'b'\n</code></pre> <p>We can also define empty strings:</p> <pre><code>x = ''\nprint(len(x))\n</code></pre> <p>As expected, the length of the empty string is 0.</p>"},{"location":"chapter-1/lesson-1.5/#operations-on-strings","title":"Operations on strings","text":""},{"location":"chapter-1/lesson-1.5/#concatenation","title":"Concatenation","text":"<p>We can concatenate two strings using the <code>+</code> operator. Concatenation is just a fancy term for joining two strings together:</p> <pre><code>string1 = 'first'\nstring2 = ','\nstring3 = 'second'\nstring4 = string1 + string2 + string3\nprint(string4)\n</code></pre> <p>The output is:</p> <pre><code>first,second\n</code></pre>"},{"location":"chapter-1/lesson-1.5/#replication","title":"Replication","text":"<p>We can make multiple copies of a string and string them all together using the <code>*</code> operator:</p> <pre><code>s = 'good'\nfive_s = s * 5\nprint(five_s)\n</code></pre> <p>The is the output:</p> <pre><code>goodgoodgoodgoodgood\n</code></pre> <p>The <code>*</code> operator has made the string look too good! This is a fine demonstration of that ancient adage: \"multiplication is repeated addition\":</p> <pre><code>s = 'good'\ns * 5 == s + s + s + s + s  # This expression evaluates to True\n</code></pre>"},{"location":"chapter-1/lesson-1.5/#comparison","title":"Comparison","text":"<p>We can compare two strings. To begin with, we have the <code>==</code> operator:</p> <pre><code>x = 'python'\nprint(x == 'python', x == 'nohtyp')\n</code></pre> <p>The output is:</p> <pre><code>True False\n</code></pre> <p>Two strings are equal if and only if both of them represent exactly the same sequence of characters.  Now, consider the following lines of code:</p> <pre><code>print('good' &gt; 'bad')\nprint('nine' &lt; 'one' )\nprint('a' &lt; 'ab' &lt; 'abc' &lt; 'b')\n</code></pre> <p>The output is:</p> <pre><code>True\nTrue\nTrue\n</code></pre> <p>It is clear from the above examples that the length of the string is not a metric used by Python to compare strings. Instead, Python uses the familiar alphabetical ordering to compare two strings. More precisely it employs what is known as lexicographic ordering:</p> <p>Lexicographic ordering</p> <p>The first characters from the two strings are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second character of both the strings are compared. This process continues until either string is exhausted.</p> <p>This leads to another question. How does Python compare two characters? The answer is given in one of Python's official tutorials:</p> <p>Python\u2019s string type uses the Unicode standard for representing characters, which lets Python programs work with different possible characters. What is the Unicode standard? Unicode is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode standard describes how characters are represented by code points. Another unfamiliar term. What is a code point? A code point value is an integer. Lexicographical ordering for strings uses the Unicode code point number to order individual characters.</p> <p>Python provides a built-in function called <code>ord</code> that returns the code point of any given character. For example:</p> <pre><code>print(ord('a'), ord('b'))\nprint(ord('a'), ord('A'))\n</code></pre> <p>The output is:</p> <pre><code>97 98\n97 65\n</code></pre> <p>Now, we clearly see why <code>'a' &lt; 'b'</code> returns <code>True</code>. This is because the code point for <code>'a'</code> and <code>'b'</code> are 97 and 98 respectively. As 97 &lt; 98, <code>'a' &lt; 'b'</code>.  We can also infer that <code>'A' &lt; 'a'</code> should return <code>True</code>.</p>"},{"location":"chapter-1/lesson-1.5/#escape-characters","title":"Escape characters","text":"<p>In Python, the backslash -  <code>\\</code> - is called the escape character. One of its uses is to represent certain white-space characters such as tabs and newlines. We will look at them one by one using the following examples:</p> <pre><code>print('This is the first sentence.\\nThis is the second sentence.')\n</code></pre> <p>The output is as follows:</p> <pre><code>This is the first sentence.\nThis is the second sentence.\n</code></pre> <p><code>\\n</code> is a newline character. Its effect is to introduce a new line. Note that even though there are two separate characters: <code>\\</code> and <code>n</code>, <code>\\n</code> is still regarded as a single character. To verify this, execute the following code. You should get 1 as the output.</p> <pre><code>x = '\\n'\nprint(len(x))\n</code></pre> <p>Another useful character is the tab: <code>\\t</code>:</p> <pre><code>print('a\\tb')\n</code></pre> <p>This will give the output:</p> <pre><code>a   b\n</code></pre> <p>There is also a way to escape the quotes: <code>\\'</code>. This can come in handy when using the apostrophe symbol in strings with single quotes:</p> <pre><code>print('India\\'s capital is New Delhi')\n</code></pre> <p>This gives the output:</p> <pre><code>India's capital is New Delhi\n</code></pre> <p>Now remove the backslash from the above string and try to print it. You will get an error. Why do you think that happens?</p>"},{"location":"chapter-1/lesson-1.5/#substrings","title":"Substrings","text":"<p>A string is a substring of another string if the first string is contained in the second. For example, <code>'good'</code> is a substring of <code>'very good'</code>, whereas <code>'very good'</code> is not a substring of <code>'verygood'</code>. Python provides a keyword - <code>in</code> - which can be used to check if a given string is a substring of another string. For example:</p> <pre><code>a = 'good'\nb = 'very good'\npresent = a in b\nprint(present)\nnot_present = b in a\nprint(not_present)\n</code></pre> <p>This gives the output:</p> <pre><code>True\nFalse\n</code></pre> <p><code>in</code> is a powerful keyword which has several other uses. It can also be used along with <code>not</code> in the following manner:</p> <pre><code>a = 'abc'\nb = 'ab'\nprint(a not in b)\n</code></pre> <p>This gives the output:</p> <pre><code>True\n</code></pre>"},{"location":"chapter-1/lesson-1.6/","title":"Lesson-1.6","text":""},{"location":"chapter-1/lesson-1.6/#lesson-16","title":"Lesson-1.6","text":""},{"location":"chapter-1/lesson-1.6/#strings","title":"Strings","text":"<p>We looked at string operations in the previous lesson. A quick recap of what we have seen so far:</p> <ul> <li>Length of a string using the <code>len</code> function</li> <li>Concatenation of two strings using the <code>+</code> operator</li> <li>Replication of strings using the <code>*</code> operator</li> <li>String comparison using relational operators such as <code>&gt;, &lt;, ==</code></li> <li>Use of <code>in</code> keyword</li> </ul> <p>In this lesson, we will explore the sequential nature of strings. This will also serve as an introduction to lists in Python. In addition, we will also look at string methods.</p>"},{"location":"chapter-1/lesson-1.6/#indexing","title":"Indexing","text":"<p>A string is a sequence of characters. Sequences support indexing. What do we mean by that? Consider the following image:</p> <p></p> <p>Given a word such as \"world\", we say that 'w' is the first letter in the word, 'o' is the second letter and so on. What we are referring to is the position of the letter in the word. The \"index\" is just a formal way of denoting the position of an element in the sequence. In computer science, starting the index from 0 is a widespread convention. This is called zero-based numbering.</p> <p>Once this is defined, we can go ahead and access characters that are at a given position in a string:</p> <pre><code>word = 'world'\nprint(word[0])\nprint(word[1])\nprint(word[2])\nprint(word[3])\nprint(word[4])\n</code></pre> <p>This will give the output:</p> <pre><code>w\no\nr\nl\nd\n</code></pre> <p>Given a variable, say <code>word</code>, that holds a string literal, <code>word[i]</code> gives the character at index <code>i</code> in the string. Informally, this would be the letter at position <code>i + 1</code> in the string. Now, let us turn to the following code:</p> <pre><code>word = 'world'\nprint(word[5])\n</code></pre> <p>This gives the following output:</p> <pre><code>Traceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(word[5])\nIndexError: string index out of range\n</code></pre> <p>The interpreter throws an <code>IndexError</code> as we are trying to access an index that is out of range. The length of the string is <code>5</code>. Since we start the index from <code>0</code>, the last character will be at index <code>4</code>. Anything greater than that is going to throw an error. Now, let us turn to the other end of the spectrum:</p> <pre><code>word = 'world'\nprint(word[-1])\n</code></pre> <p>Surprisingly, there is no error and the output is:</p> <pre><code>d\n</code></pre> <p>Python supports negative indexing. This can be best understood using the following image:</p> <p></p> <p>Think about it as follows. You keep moving down a flight of stairs starting from the top most step. When you reach the last step, you think that you cannot go down any further. At that moment, some invisible hand magically transports you back to the top most step and you begin your descent all over again. A good image that captures this analogy is the Penrose stairs:</p> <p></p> <p>Image credit: Wikipedia</p> <p>An index of <code>-1</code> points to the last element in the sequence. From this, we keep moving backwards until we reach the first element in the sequence which is at index <code>-5</code>.</p> <pre><code>word = 'world'\nprint(word[-1])\n# ... please add the remaining lines!\nprint(word[-5])\n</code></pre> <p>Unlike the Penrose stairs, we cannot keep repeating this forever. <code>print(word[-6])</code> will throw an <code>IndexError</code>.</p>"},{"location":"chapter-1/lesson-1.6/#slicing","title":"Slicing","text":"<p>Slicing is a way of extracting a substring from a string using the slice() function.</p> <p>Assume that you have a collection of email ids of students in IIT-M. Let us say all email ids are of this form:</p> <p>branch_year_number@iitm.ac.in</p> <p>Each branch is given a two-letter code. For example, <code>CS</code> stands for Computer Science and <code>ME</code> stands for Mechanical Engineering. The year is some two digit number that represents the year of joining. For example, it would be <code>11</code> if the year of joining is <code>2011</code>. Finally, <code>number</code> is a three digit roll number. Some sample email ids are as follows:</p> <pre><code>CS_10_014@iitm.ac.in\nME_11_123@iitm.ac.in\nBT_17_001@iitm.ac.in\n</code></pre> <p>Given a string, we would like to extract the roll number of the student from it. How do we do this? Python provides a way to extract this information using the concept of slicing:</p> <p></p> <pre><code>email = 'CS_10_014@iitm.ac.in'\nroll = email[6 : 9]\nprint(roll)\n</code></pre> <p>The slicing operator -  <code>start:stop</code> - will be our knife in slicing sequences! Let us see how it works. The substring that we want to extract is <code>014</code>. In terms of indices, this will be <code>6, 7, 8</code> in the string <code>email</code>. So, we start slicing at the index <code>6</code> and stop before the index <code>9</code>. In general, <code>email[start : stop]</code> will be the substring starting at index <code>start</code> and stopping before the index <code>stop</code>, i.e., the character at the index <code>stop</code> will be excluded from the substring. </p> <p>Few more examples using the same string:</p> <pre><code>email = 'CS_10_014@iitm.ac.in'\nbranch = email[0 : 2]\nyear = email[3 : 5]\nroll = email[6 : 9]\ncollege = email[10 : 14]\n# Print each one of them and check the output\n</code></pre> <p>Slicing is quite powerful. If we want the institute roll number, including the branch, we could do the following:</p> <pre><code>email = 'CS_10_014@iitm.ac.in'\nin_roll = email[ : 9]\nprint(in_roll)\n</code></pre> <p>This outputs <code>CS_10_014</code>. If no starting index is specified in the slice, then <code>start</code> will default to <code>0</code>. Likewise, if no stopping index is specified, <code>stop</code> will default to the end of the string or <code>len(email)</code>. Now, consider:</p> <pre><code>email = 'CS_10_014@iitm.ac.in'\ndomain = email[-10 : ]\nprint(domain)\n</code></pre> <p>This outputs <code>iitm.ac.in</code>. Think for a while about the output. It is just a combination of negative indexing and slicing. Use the following visual to get a better understanding of slicing:</p> <p></p> <p>Using the above visual, we can now very easily process the following slices:</p> <pre><code>word = 'world'\nprint(word[-4 : 3])\nprint(word[1 : -2])\n</code></pre>"},{"location":"chapter-1/lesson-1.6/#immutability","title":"Immutability","text":"<p>Execute the following code and observe the output:</p> <pre><code>word = 'some string'\nword[0] = 'S'\n</code></pre> <p>The interpreter throws a <code>TypeError</code> with the following error message: <code>'str' object does not support item assignment</code>. We say that something is \"mutable\" if it can be changed, modified. Therefore, an object is immutable if it cannot be changed or modified. Strings are immutable. One or more characters in the string literal present in <code>word</code> cannot be modified in-place. </p> <p>Note that this is different from the following:</p> <pre><code>word = 'some string'\nword = 'Some string'\n</code></pre> <p>Here, we are not modifying the variable <code>word</code> in-place. Instead, we are assigning it an entirely new string literal in line-2. Thus there are two different string literals -  <code>'some string'</code> and <code>'Some string'</code> - and the former has NOT been transformed into the latter.</p> <p></p> <p>The number on the arrow represents the line number in the code. <code>word</code> binds to the string on top after line-1. <code>word</code> binds to the string on the bottom after line-2. Note that there are two different strings here; one doesn't transform into the other. The concept of mutable and immutable objects will be explored in considerable detail in chapter-5.</p>"},{"location":"chapter-1/lesson-1.6/#methods","title":"Methods","text":"<p>Consider the following problem:</p> <p> </p> <p>Accept a sentence as input from the user and output the same sentence with the first letter in the sentence capitalized.</p> <p>For example, if the input is <code>'this is a chair.'</code>, the output should be <code>'This is a chair.'</code>.</p> <p>Solution</p> <pre><code>sentence = input()\ncap_sentence = sentence.capitalize()\nprint(cap_sentence)\n</code></pre> <p><code>capitalize</code> is called a method. Methods are essentially functions, but they are defined for specific objects. So, they have to be called by using the object for which they have been defined. In the case of <code>capitalize</code>, it is a method that is defined for the <code>str</code> data type. If we try to call it using an <code>int</code> object, we will get an error:</p> <pre><code>##### Alarm! Wrong code snippet!\na = 1\na.capitalize()\n##### Alarm! Wrong code snippet!\n</code></pre> <p>Getting back to the previous code snippet, <code>sentence.capitalize()</code> returns a string, which is then assigned to a new variable called <code>cap_sentence</code>. There are plenty of other methods associated with strings. Let us look at one more method which features in the solution to this interesting problem:</p> <p> </p> <p>Check whether a given string is a valid name of a person.</p> <p>It is safe to assume that we are not thinking about Elon Musk's son, in which case, a name usually has only alphabets without any special characters and numbers. The method <code>isalpha</code> checks for just this requirement:</p> <pre><code># name is some pre-defined string\nvalid = name.isalpha()\nprint(valid)\n</code></pre> <p><code>name.isalpha()</code> returns a boolean value. If every character in the string is an alphabet and the string is non-empty, it returns <code>True</code>, and <code>False</code> otherwise. A comprehensive list of string methods can be found here.</p>"},{"location":"chapter-2/lesson-2.1/","title":"Lesson-2.1","text":""},{"location":"chapter-2/lesson-2.1/#lesson-21","title":"Lesson-2.1","text":""},{"location":"chapter-2/lesson-2.1/#variables","title":"Variables","text":""},{"location":"chapter-2/lesson-2.1/#introduction","title":"Introduction","text":"<p>Variables are containers that are used to store values. Variables in Python are defined by using the assignment operator <code>=</code>. For example:</p> <pre><code>x = 1\ny = 100.\nz = \"good\"\n</code></pre> <p>Variables can also be updated using the assignment operator:</p> <pre><code>x = 1\nprint('The initial value of x is', x)\nx = 2\nprint('The value after updating x is', x)\n</code></pre> <p>The output is:</p> <pre><code>The initial value of x is 1\nThe value after updating x is 2\n</code></pre>"},{"location":"chapter-2/lesson-2.1/#assignment-operator","title":"Assignment Operator","text":"<p>The syntax of the assignment statement is as follows:</p> <pre><code>variable_name = expression\n</code></pre> <p>The assignment operator works from right to left. That is, the expression on the right is evaluated first. The value of this expression is assigned to the variable on the left. For example:</p> <pre><code>x = 1 + 2 * 3 / 2\nprint(x)\n</code></pre> <p>The output is:</p> <pre><code>4.0\n</code></pre> <p>Having a literal to the left of the assignment operator will result in an error:</p> <pre><code>##### Alarm! Wrong code snippet! #####\n3 = x\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>This will throw the following error:</p> <pre><code>SyntaxError: cannot assign to literal\n</code></pre> <p>The assignment statement maps or binds the variable name on the left to an object on the right. A closer look at the anatomy of an assignment statement:</p> <p></p> <p>The numbers on the arrow correspond to the line numbers in the code. The variables on the left side of the arrow bind to the objects on the right side after the corresponding line is executed. For example, the variable <code>x</code> binds to the object <code>8</code> - in this case an <code>int</code> literal - after line 1 is executed. Note the period at the end of line 2 which makes 10 a <code>float</code>. After the execution of line 2, <code>18.0</code> gets stored in <code>x</code>. The interesting part is line 3. Note that <code>y = x</code> makes both <code>x</code> and <code>y</code> bind to the same object. When <code>x</code> is updated in line-4, it binds to a new object. However, the value of <code>y</code> is not disturbed by this operation. It continues to be bound to the object <code>18.0</code> even after line-4 is executed.</p> <p>As a final point, the assignment operator should not be confused with the equality operator:</p> <pre><code>x = 2   # this is the assignment operator\nx == 2  # this is the equality operator\n</code></pre> <p>The assignment operator is used for creating or updating variables whereas the equality operator is used when two expressions need to be compared. They cannot be used interchangeably!</p> <p>Dynamic Typing</p> <p>Python supports what is called dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type \u2014 like <code>int</code> or <code>str</code> \u2014 but the variable itself doesn't <sup>1</sup>. For example:</p> <pre><code>a = 1\nprint(type(a))\na = 1 / 2\nprint(type(a))\na = \"IIT Madras\"\nprint(type(a))\n</code></pre> <p>The output is:</p> <pre><code>&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n</code></pre> <p>In the above example, <code>a</code> was initially bound to a value of type <code>int</code>. After its update in line 3, it was bound to a value of type <code>float</code> and after line 5, it becomes a <code>str</code>. The image in the previous section will give a clearer picture of why this is the case. </p>"},{"location":"chapter-2/lesson-2.1/#referencing-versus-defining","title":"Referencing versus Defining","text":"<p>When a variable that has already been defined is used in an expression, we say that the variable is being referenced. For example:</p> <pre><code>x = 2\nprint(x * x, 'is the square of', x)\n</code></pre> <p>In line-2, we are referencing the variable <code>x</code> which was assigned a value in line-1. If a variable is referenced before it has been assigned a value, the interpreter throws an exception called <code>NameError</code>:</p> <pre><code>print(someVar)\n</code></pre> <p>This is the output:</p> <pre><code>NameError: name 'someVar' is not defined\n</code></pre>"},{"location":"chapter-2/lesson-2.1/#keywords-and-naming-rules","title":"Keywords and Naming Rules","text":"<p>Keywords are certain words in the Python language that have a special meaning. Some of them are listed below:</p> <pre><code>not, and, or, if, for, while, in, is, def, class\n</code></pre> <p>We have already seen some of them - <code>not, and, or</code>. We will come across all these keywords in upcoming chapters. Keywords cannot be used as names for variables. For example, the following line of code will throw a SyntaxError when executed:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nand = 2\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>Along with this restriction, there are certain other rules which have to be followed while choosing the names of variables in Python <sup>2</sup>:</p> <ul> <li>A variable name can only contain alpha-numeric (alphabets and numbers) characters and underscores:<ul> <li>a - z</li> <li>A - Z</li> <li>0 - 9</li> <li>_</li> </ul> </li> <li>A variable name must start with a letter or the underscore character.</li> </ul> <p>A few observations that directly follow from the above rules:</p> <ul> <li> <p>A variable name cannot start with a number.</p> </li> <li> <p>Variable names are case-sensitive (<code>age</code>, <code>Age</code> and <code>AGE</code> are three different variables).</p> </li> </ul> <p>Note that these are not merely conventions. Violating any one of these rules will result in a <code>SyntaxError</code>. As an example, the following code will throw a <code>SyntaxError</code> when executed:</p> <pre><code>##### Alarm! Wrong code snippet! #####\n3a = 1\n##### Alarm! Wrong code snippet! #####\n</code></pre> <pre><code>SyntaxError: invalid decimal literal\n</code></pre>"},{"location":"chapter-2/lesson-2.1/#reusing-variables","title":"Reusing Variables","text":"<p>Variables can be used in computing the value of other variables. This is something that will routinely come up in programming and data science. Consider the following sequence of mathematical equations. We wish to evaluate the value of <code>z</code> at <code>x = 10</code>: $$ y=x^2 $$ $$ z=(x+1)(y+1) $$ This can be computed as follows:</p> <pre><code>x = 10\ny = x ** 2\nz = (x + 1) * (y + 1)\n</code></pre>"},{"location":"chapter-2/lesson-2.1/#multiple-assignment","title":"Multiple Assignment","text":"<p>Consider the following statement that defines two variables <code>x</code> and <code>y</code>.</p> <pre><code>x = 1\ny = 2\n</code></pre> <p>Python allows a compact way of writing this assignment on the same line. The following code assigns 1 to the variable <code>x</code> and 2 to the variable <code>y</code>:</p> <pre><code>x, y = 1, 2\n</code></pre> <p>Note that the order matters. The following code assigns 2 to the variable <code>x</code> and 1 to the variable <code>y</code>:</p> <pre><code>x, y = 2, 1\n</code></pre> <p>To understand how this works, we need to get into the concept of packing and unpacking tuples, which we will visit in chapter 5. Treat this as a useful feature for the time being. Another way of doing multiple assignments is to initialize multiple variables with the same value:</p> <pre><code>x = y = z = 10\nprint(x, y, z)\n</code></pre> <p>The output is:</p> <pre><code>10 10 10\n</code></pre> <p>Though <code>x</code>, <code>y</code> and <code>z</code> start off by being equal, the equality is broken the moment even one of the three variables is updated:</p> <pre><code>x = x * 1\ny = y * 2\nz = z * 3\nprint(x, y, z)\n</code></pre> <p>The output is:</p> <pre><code>10 20 30\n</code></pre>"},{"location":"chapter-2/lesson-2.1/#assignment-shortcuts","title":"Assignment Shortcuts","text":"<p>Execute the code given below and observe the output. What do you think is happening?</p> <pre><code>x = 1\nx += 1\nprint(x)\n</code></pre> <p><code>+=</code> is something that we haven't seen before.</p> <p><code>x += a</code></p> <p>Increments the value of  <code>x</code> by <code>a</code>. In other words, add <code>a</code> to <code>x</code> and store the result in <code>x</code>. It is equivalent to the statement <code>x = x + a</code>. </p> <p>This is not just limited to the addition operator. The following table gives a summary of the shortcuts for some of the arithmetic operators:</p> Shortcut Meaning <code>x += a</code> <code>x = x + a</code> <code>x -= a</code> <code>x = x - a</code> <code>x *= a</code> <code>x = x * a</code> <code>x /= a</code> <code>x = x / a</code> <code>x %= a</code> <code>x = x % a</code> <code>x **= a</code> <code>x = x ** a</code> <p>Note that the arithmetic operator must always come before the assignment operator in a shortcut. Swapping them will not work:</p> <pre><code>x = 1\nx =+ 1\nprint(x)\n</code></pre> <p>This will give <code>1</code> as the output. This is because <code>+</code> is treated as the unary operator here. Statements like <code>x =* 1</code> or <code>x =/ 2</code> will result in errors!</p>"},{"location":"chapter-2/lesson-2.1/#deleting-variables","title":"Deleting Variables","text":"<p>Variables can be deleted by using the <code>del</code> keyword:</p> <pre><code>x = 100\nprint('x is a variable whose value is', x)\nprint('we are now going to delete x')\ndel x\nprint(x)\n</code></pre> <p>When this code is executed, line 5 throws a <code>NameError</code>. This is because <code>x</code> was deleted in line 4 and we are trying to access a variable that is no longer defined at line 5.</p> <ol> <li> <p>Interestingly Python is both a dynamically typed and strongly typed language, head to this wiki page if you'd like to learn more about this.\u00a0\u21a9</p> </li> <li> <p>For more examples of legal and illegal variable names in python click here.\u00a0\u21a9</p> </li> </ol>"},{"location":"chapter-2/lesson-2.2/","title":"Lesson-2.2","text":""},{"location":"chapter-2/lesson-2.2/#lesson-22","title":"Lesson-2.2","text":""},{"location":"chapter-2/lesson-2.2/#input","title":"Input","text":"<p>Accepting input from the user routinely happens in programming. Any piece of software shipped to a customer needs to have a functional interface that will let the user interact with the software. We all have used apps like Facebook, Instagram and Twitter. These apps regularly accept input from the user, though we seldom look at it from a programming perspective. Take the case of commenting on a post in Facebook. The text entered in the comment box is the input. The code running in the backend processes this input and then displays it as a comment in a visually appealing form.</p> <p>Python provides a built-in function called <code>input()</code> to accept input from the user. This is a simple yet powerful function:</p> <pre><code>x = input()\nprint('The input entered by the user is', x)\n</code></pre> <p>Execute the code given above and head to the console. Here the interpreter waits patiently for you to enter text. Press Enter after entering the input. This acts as a cue for the interpreter to understand that you have completed entering your input. This text is stored in the variable <code>x</code>. The way it looks in the console is as follows:</p> <pre><code>1\nThe input entered by the user is 1\n</code></pre> <p>Sometimes we may want to prompt the user to enter a particular type of input. This can be done by passing the instruction as an argument to the input function:</p> <pre><code>x = input('Enter an integer between 0 and 10: ')\nprint('The number entered by the user is', x)\n</code></pre> <p>Let us now look at the type of the variable <code>x</code>:</p> <pre><code>x = input()\nprint('The input entered by the user is of type', type(x))\n</code></pre> <p>Execute the above code with the following input types: <code>int</code>, <code>float</code>, <code>str</code> and <code>bool</code>. What is the output in each case? We see that the <code>input()</code> function always returns a string. Even if the user enters a number, say <code>123</code>, that is processed as the string <code>'123'</code>. If we want to accept an integer as input, how do we do it? We take the help of an operation called type conversion.</p>"},{"location":"chapter-2/lesson-2.2/#type-conversion","title":"Type Conversion","text":"<p>If we want to convert a string into an integer, Python provides a built-in function called <code>int()</code>:</p> <pre><code>x = '123'\nprint('The type of x is', type(x))\ny = int(x)\nprint('The type of y is', type(y))\n</code></pre> <p>The operation in line 3 is called type conversion, i.e., we are converting an object of type <code>str</code> into an object of type <code>int</code>. The inverse operation also works. Predictably, the function needed for this purpose is <code>str()</code>:</p> <pre><code>x = 123\nprint('The type of x is', type(x))\ny = str(x)\nprint('The type of y is', type(y))\n</code></pre> <p>If we want to accept an integer input from the user, we first take a string as input and then convert it into an integer:</p> <pre><code>x = input('Enter an integer: ')\nx = int(x)\nprint('The integer entered by the user is', x)\n</code></pre> <p>Instead of writing this in two lines, we could write this in a single line:</p> <pre><code>x = int(input())\nprint('The integer entered by the user is', x)\n</code></pre> <p>What we have done in line 1 is to compose two functions. That is, pass the output of the inner function - <code>input()</code> - as the input of the outer function - <code>int()</code>. In the above code, what happens if the input entered is a float value?</p> <pre><code>x = int(input())    # user enters a float value here\n</code></pre> <p>The code will throw a <code>ValueError</code>. Let us take a concrete example. When the command <code>int('1.23')</code> is entered, the interpreter tries to convert the string <code>'1.23'</code> into an integer. But the number enclosed within the quotes is not an <code>int</code>, but a <code>float</code>. This number cannot be converted into an integer, hence the error.</p>"},{"location":"chapter-2/lesson-2.2/#built-in-functions","title":"Built-in Functions","text":"<p>We have been using the term built-in functions quite often. These are functions that have already been defined. Loosely speaking, a function in Python is an object that accepts inputs and produces outputs. For example, <code>print()</code> is a built-in function that accepts an input and prints it to the console.</p> <p>We will look at few more functions which will come in handy. </p> <ul> <li><code>round()</code> accepts a number as input and returns the integer closest to it. For example, <code>round(1.2)</code> returns <code>1</code>, while <code>round(1.9)</code> returns <code>2</code>.</li> <li><code>abs()</code> accepts a number as input and returns its absolute value. For example, <code>abs(-1.2)</code> returns <code>1.2</code>.</li> <li><code>int()</code> is a bit involved. If an integer enclosed within quotes (string) is entered as input, then the output is that integer. We have already seen this: <code>int('123')</code> is <code>123</code>. If a float is entered as input, then the decimal part is thrown away and the integer part is returned. For example, <code>int(1.2)</code> returns <code>1</code> and <code>int(-2.5)</code> returns <code>-2</code>. Do note that if a <code>float</code> is passed in the form of a string, a <code>ValueError</code> will be thrown i.e., <code>int('2.5')</code> will result in the following message: <pre><code>ValueError: invalid literal for int() with base 10: '2.5'\n</code></pre></li> <li><code>pow()</code> is another useful function. <code>pow(x, y)</code> returns the value of \\(x^{y}\\).  This performs the same function as the <code>**</code> operator. In general, the <code>**</code> operator is faster than the <code>pow</code> function. But for small numbers, the difference is not perceptible. In fact, using the <code>pow()</code> function increases readability of code. An extra feature of <code>pow()</code> is that it supports a third argument: <code>pow(x, y, z)</code> returns the value of \\(x^{y} \\text{ mod } z\\). That is, it gives the remainder when \\(x^y\\) is divided by \\(z\\).</li> <li><code>isinstance()</code> is used to check if an object is of a specified type. For example <code>isinstance(3, int)</code> returns the value <code>True</code> as the literal <code>3</code> is of type <code>int</code>.  The first argument could be any object, not just a literal. For example, if <code>x</code> is a variable of type <code>str</code> then, <code>isinstance(x, str)</code> will again return <code>True</code>.</li> </ul> <p>The Python documentation provides an exhaustive list of built-in functions.</p>"},{"location":"chapter-2/lesson-2.3/","title":"Lesson-2.3","text":""},{"location":"chapter-2/lesson-2.3/#lesson-23","title":"Lesson-2.3","text":""},{"location":"chapter-2/lesson-2.3/#conditional-statements","title":"Conditional Statements","text":"<p>Suppose you had to solve the following problem:</p> <p> </p> <p>Accept an integer as input from the user. If the number is greater than zero, print <code>positive</code> and if number is less than zero, print <code>negative</code>, else print <code>zero</code>.</p> <p>This problem can solved by so called Conditional Statements. Conditional Statements is a very important concept in Computer Science in general and are the building blocks to solutions for very complex problems. Conditional Statements, as the name suggests, allow for conditional execution of code. We will we see what this means in detail in the coming sections.</p>"},{"location":"chapter-2/lesson-2.3/#if-statement","title":"if statement","text":"<p>Let's start off with a simpler version of the earlier problem</p> <p> </p> <p>Accept an integer as input from the user. If the number is greater than zero, print <code>non-negative</code>.</p> <p><code>if</code> is a keyword in Python. The text adjacent to <code>if</code> is a boolean expression, usually called the if-condition or just the condition. Line-3 is the body of <code>if</code>. If the condition evaluates to <code>True</code>, then line-3 is executed. If it is <code>False</code>, then line-3 doesn't get executed. The following diagram captures the terms that have been introduced:</p> <p></p> <p>The control flow of the if-statement as a flow chart is given below:</p> <p></p> <p>Thus we can solve the problem with if:</p> <pre><code>x = int(input())\nif x &gt;= 0:\n    print('non-negative')\n</code></pre> <p>Note that line 3 in the solution code is indented. In this case, the indentation corresponds to four spaces. It is very important to keep this consistent throughout the program. In all lessons, the first level of indentation will have four space . To understand how indentation works and why it is necessary, consider the following code blocks:</p> <p>Lines 3-5 in the following codes make up the if-block. Lines 4 and 5 which are indented make up the body of <code>if</code>. Whenever the if-condition evaluates to <code>True</code>, the interpreter enters the body of <code>if</code> and executes the lines sequentially. The indentation helps in separating the body of the if-block from the rest of the code. </p> Positive xNegative x <p></p><pre><code># Left\nx = 1\nif x &gt;= 0:\n    print('non-negative')\n    print('inside if')\nprint('outside if')\n</code></pre> The condition is <code>True</code>. So lines 4 and 5 are going to be executed. Once we exit the if-block, the interpreter will resume execution from line 6. The output will be: <pre><code>non-negative\ninside if\noutside if\n</code></pre> <p></p><pre><code># Right\nx = -1\nif x &gt;= 0:\n    print('non-negative')\n    print('inside if')\nprint('outside if')\n</code></pre> The condition is <code>False</code>. So, lines 4 and 5 are not going to be executed. The interpreter will skip the body of <code>if</code> and directly move to line 6. The output will be <pre><code>outside if\n</code></pre>"},{"location":"chapter-2/lesson-2.3/#if-else","title":"if-else","text":"<p>Let us add one more level of complexity to the problem.</p> <p> </p> <p>Accept an integer as input from the user. If the number is greater than or equal to zero, print: <code>non-negative</code>. If the number is less than zero, print <code>negative</code>.</p> <p><code>else</code> is a keyword in Python. When the if-condition evaluates to <code>True</code>, the statements inside the body of the if-block are evaluated. When the condition evaluates to <code>False</code>, the statements inside the body of the else-block are evaluated.</p> <p>A visual representation of the control flow:</p> <p></p> <p>Now that with else we can add additional conditional branching to our code and solve the question:</p> <pre><code>x = int(input())\nif x &gt;= 0:\n    print('non-negative')\nelse:\n    print('negative')\n</code></pre> <p>Line 2 checks if <code>x</code> is greater than or equal to <code>0</code>. Upon failing that condition, the <code>else</code> block executes.</p> <p>Points to remember:</p> <ul> <li><code>if</code> and <code>else</code> are at the same level of indentation.</li> <li><code>else</code> can never occur independent of an <code>if</code> in conditional statements.</li> <li><code>else</code> cannot have any new condition associated with it.</li> </ul> <p>The following code demonstrates the last two points:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nelse:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n\n##### Alarm! Wrong code snippet! #####\nx, y = 1, 2\nif x &gt;= y:\n    print(1)\nelse x &lt; y:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n</code></pre>"},{"location":"chapter-2/lesson-2.3/#if-elif-else","title":"if-elif-else","text":"<p>This final tool will help us solve the original problem:</p> <p> </p> <p>Accept an integer as input from the user. If the number is greater than zero, print <code>positive</code> and if number is less than zero, print <code>negative</code>, else print <code>zero</code>.</p> <p><code>elif</code> is a keyword in Python. It is a shorthand for else-if. With this final weapon in our conditional statements arsenal, we can solve the problem as thus</p> <pre><code>x = int(input())\nif x &gt; 0:\n    print('positive')\nelif x == 0:\n    print('zero')\nelse:\n    print('negative')\n# End of code\n</code></pre> <p>To understand how this works, let us consider three different inputs and the corresponding outputs.</p> Input Output x = 1 positive x = 0 zero x = -1 negative <p>The entire <code>if</code>-<code>elif</code>-<code>else</code> block has three sub-blocks in it:</p> <ul> <li>if-block: lines 2-3</li> <li>elif-block: lines 4-5</li> <li>else-block: lines 6-7</li> </ul> <p>This is the process followed by the interpreter in executing the <code>if</code>-<code>elif</code>-<code>else</code> block:</p> <ul> <li>If the if-condition evaluates to <code>True</code>, line 3 is executed and then the control transfers to line-8.</li> <li>If the if condition evaluates to <code>False</code>, the control transfers to the elif block. If the elif condition evaluates to <code>True</code>, then line 5 is executed and then the control transfers to line 8.</li> <li>If the elif condition is <code>False</code>, the control transfers to the else block and line 7 is executed. As there are no more conditions to check, control naturally transfers to line 8.</li> </ul> <p>A visual representation of the process is given below:</p> <p></p> <p>The general syntax:</p> <pre><code>if &lt;condition_1&gt;:\n    &lt;statement_1&gt;\nelif &lt;condition_2&gt;:\n    &lt;statement_2&gt;\nelse:\n    &lt;statement_3&gt;\n</code></pre> <p>Some features to note:</p> <ul> <li>Exactly one of the three statements gets executed.</li> <li>The moment either an <code>if</code> or an <code>elif</code> condition evaluates to <code>True</code>, the body of that block is executed and the flow exits out of the entire <code>if</code>-<code>elif</code>-<code>else</code> block.</li> <li>There could be multiple <code>elif</code> conditions after the <code>if</code>.</li> <li>An <code>else</code> condition cannot come before an <code>elif</code>. The final <code>else</code> block is not mandatory and can be removed. If the <code>else</code> is present, it can only come at the end.</li> </ul>"},{"location":"chapter-2/lesson-2.3/#nested-conditional-statements","title":"Nested conditional statements","text":"<p>Consider the following problem:</p> <p> </p> <p>Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print <code>in ascending order</code>. If not, print <code>not in ascending order</code>.</p> <p>An incomplete solution is given below:</p> <pre><code># Incomplete solution\nx = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    print('in ascending order')\nelse:\n    print('not in ascending order')\n</code></pre> <p>The problem with the above solution is that it doesn't check if <code>y &lt; z</code>. So, for an input like <code>x, y, z = 1, 3, 2</code>, it will print <code>in ascending order</code>, which is incorrect. The complete solution is given below:</p> <pre><code>x = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    if y &lt; z:\n        print('in ascending order')\n    else:\n        print('not in ascending order')\nelse:\n    print('not in ascending order')\n</code></pre> <p>Whenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if condition. Since line 7 makes up the body of the if block starting at line 6, it has one level of indentation with respect to line 6. However, line 6 is already at the first level of indentation with respect to line 5, so line 7 has two levels of indentation with respect to line 5. According to the convention we have chosen, two levels of indentation will correspond to eight spaces.</p> <p>Having a conditional statement inside another conditional statement is called nesting. The if-block from lines 5-9 forms the outer block. The if-else block from lines 6-9 forms the inner block. The <code>else</code> in line 8 is paired with the <code>if</code> in line 6 as they are at the same level of indentation. For similar reasons, the <code>else</code> in line 10 is paired with the <code>if</code> in line 5.</p>"},{"location":"chapter-2/lesson-2.3/#defining-variables-inside-if","title":"Defining variables inside <code>if</code>","text":"<p>Consider the following snippet of code:</p> <pre><code>x = int(input())\nif x % 5 == 0:\n    output = 'the number is divisible by 5'\nprint(output)\n</code></pre> <p>Run the code multiple times, varying the input each time. What do you observe?</p> <p>Whenever the input is a multiple of 5, the code runs without any error. When the input is not divisible by 5, the code throws a <code>NameError</code>. This is because, we are trying to reference a variable that has not been defined. The variable <code>output</code> is created only if line 3 is executed during run-time. Its mere presence in the code is not enough.</p>"},{"location":"chapter-2/lesson-2.4/","title":"Lesson-2.4","text":""},{"location":"chapter-2/lesson-2.4/#lesson-24","title":"Lesson-2.4","text":""},{"location":"chapter-2/lesson-2.4/#library","title":"Library","text":"<p>A library is a collection of functions that share a common theme. This is a loose definition and will become clear when we start working with a library.</p>"},{"location":"chapter-2/lesson-2.4/#calendar","title":"<code>calendar</code>","text":"<p>Consider the following problem:</p> <p> </p> <p>In the year \\(3000\\), \\(15^{\\text{th}}\\)\u200b August will fall on which day of the week?</p> <p>Python to the rescue:</p> <pre><code>import calendar\ncalendar.prmonth(3000, 8)\n</code></pre> <p>When the above code is executed, the output is:</p> <pre><code>    August 3000\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n</code></pre> <p>15th of August falls on a Friday. Isn't that lovely? It took just two lines of code! <code>calendar</code> is one among several libraries in Python's standard library. A comprehensive list can be found here. Going back to the code, <code>calendar</code> is the name of the library and <code>import</code> is the keyword used to include this library as a part of the code.</p> <p><code>calendar</code> is a collection of functions that are related to calendars. <code>prmonth()</code> is one such function. It accepts <code>&lt;year&gt;</code> and <code>&lt;month&gt;</code>, as input and displays the calendar for <code>&lt;month&gt;</code> in the year <code>&lt;year&gt;</code>. If we want to use a function in <code>calendar</code>, we must first import the library. Let us see what happens if skip this step:</p> <pre><code># import calendar\ncalendar.prmonth(3000, 8)\n</code></pre> <p>It gives the following error:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nNameError: name 'calendar' is not defined\n</code></pre> <p>To access a function defined inside a library, we use the following syntax:</p> <pre><code>&lt;calendar&gt;.&lt;function&gt;(&lt;arguments&gt;)\n</code></pre> <p>Another way to solve the problem is to use the function <code>weekday</code>:</p> <pre><code>import calendar\nprint(calendar.weekday(3000, 8, 15))\n</code></pre> <p>The output of the above code is <code>4</code>. Days are mapped to numbers as follows:</p> Day Number Monday 0 Tuesday 1 Wednesday 2 Thursday 3 Friday 4 Saturday 5 Sunday 6"},{"location":"chapter-2/lesson-2.4/#time","title":"<code>time</code>","text":"<p>Let us now try to answer this hypothetical question:</p> <p> </p> <p>You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time.</p> <p>Solution</p> <pre><code>from time import ctime\nprint('The current time is:', ctime())\n</code></pre> <p>The output is:</p> <pre><code>The current time is: Fri Apr  2 12:24:43 2021\n</code></pre> <p>The syntax of the import statement in line-1 looks different. <code>from</code> is a new keyword. The first line of the code is essentially doing the following: from the library called <code>time</code> import the function called <code>ctime</code>. This way of importing functions is useful when we need just one or two functions from a given library:</p> <pre><code>from time import ctime, sleep\nprint('Current time is:', ctime())\nprint('I am going to sleep for 10 seconds')\nsleep(10)\nprint('Current time is:', ctime())\n</code></pre> <p><code>sleep(x)</code> is a function in <code>time</code> that suspends the execution of the program for <code>x</code> seconds. If we would be using several functions in the library, then it is a bad idea to keep importing each of them individually. In such cases, it is good to fall back on importing the entire library.</p>"},{"location":"chapter-2/lesson-2.4/#this","title":"<code>this</code>","text":"<p>As a fun exercise, consider the following code:</p> <pre><code>import this\n</code></pre> <p>This gives the following output:</p> <pre><code>The Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n</code></pre> <p>These are some nuggets of wisdom from Tim Peters, a \"major contributor to the Python programming language\" <sup>1</sup>. Some of the points make immediate sense, such as \"readability counts\".</p> <ol> <li> <p>The brain behind the Zen \u21a9</p> </li> </ol>"},{"location":"chapter-3/lesson-3.1/","title":"Lesson-3.1","text":""},{"location":"chapter-3/lesson-3.1/#lesson-31","title":"Lesson-3.1","text":""},{"location":"chapter-3/lesson-3.1/#loops","title":"Loops","text":""},{"location":"chapter-3/lesson-3.1/#introduction","title":"Introduction","text":"<p>Consider the following problem:</p> <p> </p> <p>Print the sum of the first five positive integers.</p> <p>With our current knowledge of Python, how do we solve this?</p> <p></p><pre><code>print(1 + 2 + 3 + 4 + 5)\n</code></pre> Not a very elegant solution, but it gets the job done. Now, how about the following problem?  <p> </p> <p>Print the sum of the first 1,000,000 positive integers.</p> <p>The earlier approach is not going to work. One million is just too big a number to count down to. Let's take a diversion and instead ponder: If it takes about five seconds on average to write a number followed by the <code>+</code> symbol, how much time will it take to find the sum of all 1 million numbers? Let's find an answer using python:</p> <pre><code>num = 1_000_000     # _ in a number is used when we have large numbers; improves readability\navg_time = 5\nseconds = num * avg_time\nminutes = seconds / 60\nhours = minutes / 60\ndays = hours / 24\nprint('Approximate number of days =', round(days))\n</code></pre> <p>It will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don't need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in.</p>"},{"location":"chapter-3/lesson-3.1/#while","title":"<code>while</code>","text":"<p><code>while</code> is a keyword in Python. The expression adjacent to <code>while</code> is a boolean expression, called the while condition, or just the condition. The loopy solution to the problem:</p> <pre><code>total = 0\nnum = 0\nwhile num &lt; 1_000_000:\n    num = num + 1\n    total = total + num\nprint(total)\n# Rest of code will follow below this comment\n</code></pre> <p>There's a lot to unpack here. Lines 4 and 5 make up the body of while. If the condition evaluates to <code>True</code>, control enters the body of while. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to line 3, where the condition is evaluated again. As long as the condition is <code>True</code>, the body of while keeps getting executed. The moment the condition becomes <code>False</code>, the body of the while is skipped and control transfers to line 6. The body of the while loop must always be indented; this helps to separate it from the rest of the code.</p> <p>A visual representation is given below:</p> <p></p> <p>Let us consider another example:</p> <p> </p> <p>Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer.</p> <p>The visual representation of the code is given below:</p> <p></p> <p>One final example before closing this section:</p> <p> </p> <p>Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer.</p> <p>Solution</p> <pre><code># Initialize\nnum = int(input())\nmax_num = 0\n# Loop\nwhile num &gt;= 0:\n    if num &gt; max_num:\n        max_num = num\n    num = int(input())\n# Print output\nprint(max_num)\n</code></pre> <p>Note that lines 6-8 make up the body of <code>while</code> and are indented. Lines 1, 4 and 9 have some comments which are meant to help the reader understand what is happening in the code that follows them.</p>"},{"location":"chapter-3/lesson-3.1/#loop-control-statements","title":"Loop Control Statements","text":"<p><code>break</code> and <code>continue</code> are keywords in Python and are associated with loops. The <code>break</code> statement is used to exit out of a loop without executing any code that comes below it. For example:</p> <pre><code>num = 1\nwhile True:\n    if (num % 2 == 0) and (num % 3 == 0) and (num % 4 == 0):\n        break\n    num = num + 1\nprint(num)\n</code></pre> <p>The above code prints the smallest positive integer that is divisible by 2, 3 and 4, which is the same as the LCM of \\((2, 3, 4)\\). The moment this number is found, the code breaks out of the loop.</p> <p>The <code>continue</code> statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example:</p> <pre><code>x = 0\nwhile x &lt; 50:\n    x = x + 1\n    if x % 3 != 0:\n        continue\n    print(x)\n</code></pre> <p>The code given above prints all positive integers less than or equal to 50 that are divisible by 3. Whenever <code>x</code> is not divisible by 3, we do not want to print the number, so we continue to the next iteration.</p> <p>The similarity between <code>break</code> and <code>continue</code> is that whenever either statement is encountered in a loop, all the statements that follow it are skipped. The main difference is that, <code>break</code> exits the loop whereas <code>continue</code> moves to the next iteration. </p> <p><code>break</code> and <code>continue</code> are interesting features offered by Python. However, it is important to note that both the examples that we just discussed can be written without using <code>break</code> or <code>continue</code>. It is left as an exercise for the reader to figure out how this can be done.</p>"},{"location":"chapter-3/lesson-3.2/","title":"Lesson-3.2","text":""},{"location":"chapter-3/lesson-3.2/#lesson-32","title":"Lesson-3.2","text":""},{"location":"chapter-3/lesson-3.2/#loops","title":"Loops","text":""},{"location":"chapter-3/lesson-3.2/#for-loop","title":"<code>for</code> loop","text":"<p>Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers. We could do this using a while loop but let's try a different kind of a loop now, the <code>for</code> loop:</p> <pre><code>for i in range(5):\n    print(i)\n# A dummy line\n</code></pre> <p>The output is:</p> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p><code>for</code> and <code>in</code> are keywords in Python. <code>range</code> is an object that represents a sequence of numbers. Line-2 is the body of the loop. An intuitive understanding of the code given above is as follows:</p> <ul> <li>In each iteration of the loop, an element in the sequence is picked up and is printed to the console.</li> <li>Assuming that the sequence is ordered from left to right, the leftmost element is the first to be picked up.</li> <li>The sequence is processed from left to right.</li> <li>Once the rightmost element has been printed to the console, control returns to line 1 for one last time. Since there are no more elements to be read in the sequence, the control exits the loop and moves to line 3.</li> </ul> <p>A visual representation is given below:</p> <p></p> <p>Similar to <code>while</code> loops and <code>if</code>-<code>else</code> blocks, the body of a <code>for</code> loop should be indented.</p>"},{"location":"chapter-3/lesson-3.2/#range","title":"range()","text":"<p>Now let's dive a bit deeper into this <code>range()</code> function that we have been using. This function predictably returns a sequence, or a range if you will, of numbers. <code>range(5)</code> results in the following sequence: \\(0, 1, 2, 3, 4\\). In general, <code>range(n)</code> creates the sequence:  \\(0, 1, ..., n - 1\\). <code>range</code> is quite versatile. The following code prints all two digit numbers greater than zero:</p> <pre><code>for i in range(10, 100):\n    print(i)\n</code></pre> <p><code>range(10, 100)</code> represents the sequence \\(10, 11, ..., 99\\). In general, <code>range(start, stop)</code> represents the sequence <code>start, start + 1, ..., stop - 1</code>. Let us add another level of complexity. The following code prints all even two digit natural numbers:</p> <pre><code>for i in range(10, 100, 2):\n    print(i)\n</code></pre> <p><code>range(10, 100, 2)</code> represents the sequence <code>10, 12, ..., 98</code>. In general, <code>range(start, stop, step)</code> represents the sequence <code>start, start + step, start + 2 * step, ..., last</code>, where <code>last</code> is the largest element in this sequence that is less than <code>stop</code>. This is true when the <code>step</code> parameter is positive.</p> <p>The following are equivalent:</p> <ul> <li><code>range(n)</code></li> <li><code>range(0, n)</code></li> <li><code>range(0, n, 1)</code></li> </ul> <p>So far we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order:</p> <pre><code>for i in range(98, 9, -2):\n    print(i)\n</code></pre> <p>For a negative <code>step</code> value, <code>range(start, stop, step)</code> represents the sequence <code>start, start + step, start + 2 * step, ..., last</code>, where <code>last</code> is the smallest element in the sequence greater than <code>stop</code>.</p> <p>Now, consider the following code:</p> <pre><code>for i in range(5, 5):\n    print(i)\n</code></pre> <p><code>range(5, 5)</code> is an empty sequence. So, the above code will not print anything. Another instance of an empty sequence:</p> <pre><code>for i in range(10, 5):\n    print(i)\n</code></pre> <p>The point to note is that neither of these code snippets produces any error. Finally, try executing the following snippet and observe the output.</p> <pre><code>##### Alarm! Wrong code snippet! #####\nfor i in range(0.0, 10.0):\n    print(i)\n##### Alarm! Wrong code snippet! #####\n</code></pre>"},{"location":"chapter-3/lesson-3.2/#iterating-through-strings","title":"Iterating through Strings","text":"<p>Since a string is a sequence of characters, we can use the <code>for</code> loop to iterate through strings. The following code will print each character of the string <code>x</code> in one line:</p> <pre><code>word = 'good'\nfor char in word:\n    print(char)\n</code></pre> <p>The output is:</p> <pre><code>g\no\no\nd\n</code></pre> <p>We can add some more code to enrich the output:</p> <pre><code>word = 'good'\ncount = 1\nfor char in word:\n    print(char, 'occurs at position', count, 'in the string', word)\n    count = count + 1\n</code></pre> <p>The output is:</p> <pre><code>g occurs at position 1 in the string good\no occurs at position 2 in the string good\no occurs at position 3 in the string good\nd occurs at position 4 in the string good\n</code></pre>"},{"location":"chapter-3/lesson-3.3/","title":"Lesson-3.3","text":""},{"location":"chapter-3/lesson-3.3/#lesson-33","title":"Lesson-3.3","text":""},{"location":"chapter-3/lesson-3.3/#nested-loops","title":"Nested loops","text":"<p>Consider the following problem:</p> <p> </p> <p>Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.</p> <p>Solution</p> <pre><code>count = 0\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            count = count + 1\nprint(count)\n</code></pre> <p>The code given above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner-loop. There are multiple levels of indentation here. Line-3 is the beginning of a new <code>for</code> loop, so line 4 is indented with respect to line 3. As line 4 is an if statement, line 5 is indented with respect to line 4. </p> <p>This problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem. Let us look at one more problem:</p> <p> </p> <p>Find the number of prime numbers less than \\(n\\), where \\(n\\) is some positive integer.</p> <p>Solution</p> <pre><code>n = int(input())\ncount = 0\nfor i in range(2, n + 1):\n    flag = True\n    for j in range(2, i):\n        if i % j == 0:\n            flag = False\n            break\n    if flag:\n        count = count + 1\nprint(count)\n</code></pre> <p>The basic idea behind the solution is as follows:</p> <ul> <li>The outer for loop goes through each element in the sequence \\(2, 3, ..., n\\). <code>i</code> is the loop variable for this sequence.</li> <li>We begin with the guess that <code>i</code> is prime. In code, we do this by setting <code>flag</code> to be <code>True</code>.</li> <li>Now, we go through all potential divisors of <code>i</code>. This is represented by the sequence \\(2, 3, ..., i - 1\\). Variable <code>j</code> is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on <code>i</code>, the loop variable for the outer loop.</li> <li>If <code>j</code> divides <code>i</code>, then <code>i</code> cannot be a prime. We correct our initial assumption by updating <code>flag</code> to <code>False</code> whenever this happens. As we know that <code>i</code> is not prime, there is no use of continuing with the inner-loop, so we break out of it.</li> <li>If <code>j</code> doesn't divide <code>i</code> for any <code>j</code> in this sequence, then <code>i</code> is a prime. In such a situation, our initial assumption is right, and <code>flag</code> stays <code>True</code>.</li> <li>Once we are outside the inner-loop, we check if <code>flag</code> is <code>True</code>. if that is the case, then we increment count as we have hit upon a prime number.</li> </ul> <p>Some important points regarding nested loops:</p> <ul> <li>Nesting is not restricted to <code>for</code> loops. Any one of the following combinations is possible:</li> <li><code>for</code> inside <code>for</code></li> <li><code>for</code> inside <code>while</code></li> <li><code>while</code> inside <code>while</code></li> <li><code>while</code> inside <code>for</code></li> <li>Multiple levels of nesting is possible.</li> </ul>"},{"location":"chapter-3/lesson-3.3/#while-versus-for","title":"<code>while</code> versus <code>for</code>","text":"<p><code>for</code> loops are typically used in situations where the number of iterations can be quantified, whereas <code>while</code> loops are used in situations where the number of iterations cannot be quantified exactly. This doesn't mean that the number of iterations in a <code>for</code> loop is always constant. For example:</p> <pre><code>n = int(input())\nfor i in range(n):\n    print(i ** 2)\n</code></pre> <p>In the code given above, the number of iterations will keep varying every time the code is run with a different input. But given the knowledge of the input, the number of iterations is fixed. On the other hand, consider the following example:</p> <pre><code>x = int(input())\nwhile x &gt; 0:\n    x = int(input())\n</code></pre> <p>The number of iterations in the above code can be determined only after it terminates. There is no way of quantifying the number of iterations as an explicit function of user input.</p>"},{"location":"chapter-3/lesson-3.3/#print-end-sep","title":"print: <code>end</code>, <code>sep</code>","text":""},{"location":"chapter-3/lesson-3.3/#end","title":"<code>end</code>","text":"<p>Consider the following problem:</p> <p> </p> <p>Accept a positive integer <code>n</code> as input and print all the numbers from 1 to n in a single line separated by commas.</p> <p>For a given value of <code>n</code>, say <code>n</code> = 9, we want the output to be:</p> <pre><code>1,2,3,4,5,6,7,8,9\n</code></pre> <p>The following solution won't work:</p> <pre><code>n = int(input())\nfor i in range(1, n + 1):\n    print(i, ',')\n</code></pre> <p>For <code>n</code> = 9, this will give the following output:</p> <pre><code>1 ,\n2 ,\n3 ,\n4 ,\n5 ,\n6 ,\n7 ,\n8 ,\n9 ,\n</code></pre> <p>Thankfully, the print function provides a way to solve this problem:</p> <pre><code>n = int(input())\nfor i in range(1, n):\n    print(i, end = ',')\nprint(n)\n</code></pre> <p>For <code>n</code> = 9, this will give the required output:</p> <pre><code>1,2,3,4,5,6,7,8,9\n</code></pre> <p>Whenever we use the <code>print()</code> function, it prints the expression passed to it and immediately follows it up by printing a newline. This is the default behaviour of <code>print()</code>. It can be altered by using a special argument called <code>end</code>. The default value of <code>end</code> is set to the newline character. So, whenever the end argument is not explicitly specified in the print function, a newline is appended to the input expression by default. In the code given above, by setting <code>end</code> to be a comma, we are forcing the <code>print()</code> function to insert a comma instead of a newline at the end of the expression passed to it. It is called <code>end</code> because it is added at the end. To get a better picture, consider the following code:</p> <pre><code>print()\nprint(end = ',')\nprint(1)\nprint(1, end = ',')\nprint(2, end = ',')\nprint(3, end = ',')\n</code></pre> <p>This output is:</p> <pre><code>,1\n1,2,3,\n</code></pre> <p>Even though nothing is being passed to the print function in the first line of code, the first line in the output is a newline because the default value of <code>end</code> is a newline character (<code>'\\n'</code>). No expression is passed as input to print in the second line of code as well, but <code>end</code> is set to <code>,</code>. So, only a comma is printed. Notice that line 3 of the code is printed in line 2 of the output. This is because <code>end</code> was set to <code>,</code> instead of the newline character in line 2 of the code.</p>"},{"location":"chapter-3/lesson-3.3/#sep","title":"<code>sep</code>","text":"<p>If multiple expressions are passed to the <code>print()</code> function, it prints all of them in the same line, by adding a space between adjacent expressions. For example:</p> <pre><code>print('this', 'is', 'cool')\n</code></pre> <p>The output is:</p> <pre><code>this is cool\n</code></pre> <p>What if we do not want the space or if want some other separator? This can be done using <code>sep</code>:</p> <pre><code>print('this', 'is', 'cool', sep = ',')\n</code></pre> <p>The output is:</p> <pre><code>this,is,cool\n</code></pre> <p>We could also have an empty string as the separator:</p> <pre><code>print('this', 'is', 'cool', sep = '')\n</code></pre> <p>The output will then be:</p> <pre><code>thisiscool\n</code></pre>"},{"location":"chapter-3/lesson-3.3/#end-and-sep","title":"<code>end</code> and <code>sep</code>","text":"<p>Let us look at one final example that makes use of both <code>end</code> and <code>sep</code>:</p> <p> </p> <p>Accept a positive integer <code>n</code>, which is also a multiple of 3, as input and print the following pattern:</p> <pre><code>|1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n|\n</code></pre> <p>For <code>n = 9</code>, we would like to print:</p> <pre><code>|1,2,3|4,5,6|7,8,9|\n</code></pre> <p>Solution</p> <pre><code>n = int(input())\nprint('|', end = '')\nfor i in range(1, n + 1, 3):\n    print(i, i + 1, i + 2, sep = ',', end = '|')\nprint()\n</code></pre> <p>Notice that the <code>for</code> loop iterates in steps of 3 starting from 1. To print the comma separated triplet <code>i,i + 1,i + 2</code>, <code>sep</code> is set to <code>,</code>. After printing each triplet, the symbol <code>|</code> needs to be printed. This is achieved by setting <code>end</code> to be equal to <code>|</code>. Line 2 makes sure that the symbol <code>|</code> is present at the beginning of the pattern. The last <code>print()</code> statement outside the loop is there so that the prompt can move to the next line on the console once the pattern has been printed. You can try removing the last line and see how that changes the output on the console.</p>"},{"location":"chapter-3/lesson-3.4/","title":"Lesson-3.4","text":""},{"location":"chapter-3/lesson-3.4/#lesson-34","title":"Lesson-3.4","text":""},{"location":"chapter-3/lesson-3.4/#formatted-printing","title":"Formatted printing","text":"<p>Consider the following program:</p> <pre><code>name = input()\nprint('Hi,', name, '!')\n</code></pre> <p>When this code is executed with <code>Sachin</code> as the input, we get the following output:</p> <pre><code>Hi, Sachin !\n</code></pre> <p>This looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text in the way we want.</p>"},{"location":"chapter-3/lesson-3.4/#f-strings","title":"f-strings","text":"<p>The first method that we will look at is called formatted string literals or f-strings for short. Let us jump into the syntax:</p> <pre><code>name = input()\nprint(f'Hi, {name}!')\n</code></pre> <p>When this code is executed with <code>Sachin</code> as the input, we get the following output:</p> <pre><code>Hi, Sachin!\n</code></pre> <p>The messy formatting has been corrected. Let us take a closer look at the string that was passed to <code>print()</code>:</p> <pre><code>f'Hi, {name}'\n</code></pre> <p>This is called a formatted string literal or f-string. The <code>f</code> in front of the string differentiates f-strings from normal strings. f-string is an object which when evaluated results in a string. The value of the variable <code>name</code> is inserted in place of <code>{name}</code> in the f-string. Two things are important for f-strings to do our bidding:</p> <ul> <li>The <code>f</code> in front of the string.</li> <li>The curly braces enclosing the variable.</li> </ul> <p>Let us see what happens if we miss one of these two:</p> <pre><code>name = 'Sachin'\nprint('Hi, {name}!')\nprint(f'Hi, name!')\n</code></pre> <p>This will give the output:</p> <pre><code>Hi, {name}!\nHi, name!\n</code></pre> <p>Let us now look at few other examples:</p> <pre><code>l, b = int(input()), int(input())\nprint(f'The length of the rectangle is {l} units')\nprint(f'The breadth of the rectangle is {b} units')\nprint(f'The area of the rectangle is {l * b} square units')\n</code></pre> <p>For <code>l = 4, b = 5</code>, the output is:</p> <pre><code>The length of the rectangle is 4 units\nThe breadth of the rectangle is 5 units\nThe area of the rectangle is 20 square units\n</code></pre> <p>Going back to the code, lines 2 and 3 are quite clear. Notice that line-4 has an expression \u2014 <code>l * b</code> \u2014 inside the curly braces and not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some <code>{expression}</code> in it, the interpreter will substitute the value of <code>expression</code> in the place of <code>{expression}</code>. Another example:</p> <pre><code>x = int(input())\nprint(f'Multiplication table for {x}')\nfor i in range(1, 11):\n    print(f'{x} X {i} \\t=\\t {x * i}')\n</code></pre> <p>For an input of 3, this will give the following result:</p> <pre><code>Multiplication table for 3\n3 X 1   =    3\n3 X 2   =    6\n3 X 3   =    9\n3 X 4   =    12\n3 X 5   =    15\n3 X 6   =    18\n3 X 7   =    21\n3 X 8   =    24\n3 X 9   =    27\n3 X 10  =    30\n</code></pre> <p>The <code>\\t</code> is a tab character. It has been added before and after the <code>=</code>. Remove both the tabs and run the code. Do you see any change in the output?</p> <p>Till now we have passed f-strings to the <code>print()</code> function. Nothing stops us from using it to define other string variables:</p> <pre><code>name = input()\nqual = input()\ngender = input()\nif qual == 'phd':\n    name_respect = f'Dr. {name}'\nelif gender == 'male':\n    name_respect = f'Mr. {name}'\nelif gender == 'female':\n    name_respect = f'Ms. {name}'\nprint(f'Hello, {name_respect}')\n</code></pre> <p>Try to guess what this code is doing.</p>"},{"location":"chapter-3/lesson-3.4/#format","title":"<code>format()</code>","text":"<p>Another way to format strings is using a string method called <code>format()</code>.</p> <pre><code>name = input()\nprint('Hi, {}!'.format(name))\n</code></pre> <p>In the above string, the curly braces will be replaced by the value of the variable <code>name</code>.  Another example:</p> <pre><code>l, b = int(input()), int(input())\nprint('The length of the rectangle is {} units'.format(l))\nprint('The breadth of the rectangle is {} units'.format(b))\nprint('The area of the rectangle is {} square units'.format(l * b))\n</code></pre> <p>Let us now print the multiplication table using <code>format()</code>:</p> <pre><code>x = int(input())\nfor i in range(1, 11):\n    print('{} X {} \\t=\\t {}'.format(x, i, x * i))\n</code></pre> <p>The output will be identical to the one we saw when we used f-strings. Some points to note in line 3 of this code-block. There are three pairs of curly braces. The values that go into these three positions are given as three arguments in the <code>format()</code> function. Starting from the left, the first pair of curly braces in the string is replaced by the first argument in <code>format</code>, the second pair by the second argument and so on. Few more examples:</p> <p>First, consider the following code: </p> <pre><code>fruit1 = 'apple'\nfruit2 = 'banana'\nprint('{} and {} are fruits'.format(fruit1, fruit2))\n</code></pre> <p>In this code, the mapping is implicit. The first pair of curly braces is mapped to the first argument and so on. This can be made explicit by specifying which argument a particular curly braces will be mapped to:</p> <pre><code>fruit1 = 'apple'\nfruit2 = 'banana'\nprint('{0} and {1} are fruits'.format(fruit1, fruit2))\n</code></pre> <p>The integer inside the curly braces gives the index of the argument in the <code>format()</code> function. The arguments of the <code>format()</code> function are indexed from 0 and start from the left. Changing the order of arguments will change the output. A third way of writing this as follows:</p> <pre><code>fruit1 = 'apple'\nfruit2 = 'banana'\nprint('{string1} and {string2} are fruits'.format(string1 = fruit1, string2 = fruit2))\n</code></pre> <p>This method uses the concept of keyword arguments which we will explore in the lessons on functions in the next chapter. Until then, let us put this last method on the back-burner.</p>"},{"location":"chapter-3/lesson-3.4/#format-specifiers","title":"Format specifiers","text":"<p>Consider the following code:</p> <pre><code>pi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx}')\n</code></pre> <p>This gives the following output:</p> <pre><code>The value of pi is approximately 3.142857142857143\n</code></pre> <p>There are too many numbers after the decimal point. In many real world applications, having two or at most three places after the decimal point is sufficient. In fact, having as many as fifteen numbers after the decimal point only confuses readers. Format specifiers are a way to solve this problem:</p> <pre><code>pi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.2f}')\n</code></pre> <p>This gives the following output:</p> <pre><code>The value of pi is approximately 3.14\n</code></pre> <p>Let us look at the content inside the curly braces: <code>{pi_approx:.2f}</code>. The first part before the <code>:</code> is the variable. Nothing new here. The part after <code>:</code> is called a format specifier. <code>.2f</code> means the following:</p> <ul> <li><code>.</code>  -  this signifies the decimal point.</li> <li><code>2</code>  -  since this comes after the decimal point, it stipulates that there should be exactly two numbers after the decimal point. In other words, the value (<code>pi_approx</code>) should be rounded off to two decimal places.</li> <li><code>f</code>  -  this signifies that we are dealing with a <code>float</code> value.</li> </ul> <p>Let us consider a variant of this code:</p> <pre><code>pi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.3f}')\n</code></pre> <p>This gives the following output:</p> <pre><code>The value of pi is approximately 3.143\n</code></pre> <p>Let us now take another example. Let us say we want to print the marks of three students in a class:</p> <pre><code>roll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1}')\nprint(f'{roll_2}: {marks_2}')\nprint(f'{roll_3}: {marks_3}')\n</code></pre> <p>This gives the following output:</p> <pre><code>BSC1001: 90.5\nBSC1002: 100\nBSC1003: 90.15\n</code></pre> <p>While this is not bad, we would like the marks to be right aligned and have a uniform representation for the marks. The following code helps us achieve this:This is what we wish to see:</p> <pre><code>roll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1:10.2f}')\nprint(f'{roll_2}: {marks_2:10.2f}')\nprint(f'{roll_3}: {marks_3:10.2f}')\n</code></pre> <p>The output of the above code will be:</p> <pre><code>BSC1001:      90.50\nBSC1002:     100.00\nBSC1003:      90.15\n</code></pre> <p>This is much more neater. </p> <p>The part that might be confusing is the second curly braces in each of the print statements. Let us take a closer look: <code>{marks_1:10.2f}</code>. The part before the <code>:</code> is the variable. The part after the <code>:</code> is <code>10.2f</code>. Here again, <code>.2f</code> signifies that the float value should be rounded off to two decimal places. The <code>10</code> before the decimal point is the minimum width of the column used for printing this value. If the number has fewer than 10 characters (including the decimal point), this will be compensated by adding spaces before the number.</p> <p>For a better understanding of this concept, let us turn to printing integers with a specific formatting. This time, we will use the <code>format()</code> function:</p> <pre><code>print('{0:5d}'.format(1))\nprint('{0:5d}'.format(11))\nprint('{0:5d}'.format(111))\nprint('{:5d}'.format(1111))\nprint('{:5d}'.format(11111))\nprint('{:5d}'.format(111111))\n</code></pre> <p>This gives the following output:</p> <pre><code>    1\n   11\n  111\n 1111\n11111\n111111\n</code></pre> <p>Points to note in the code:</p> <ul> <li>The <code>d</code> stands for integer.</li> <li>First three print statements have the index of the argument \u2014 <code>0</code> in this case \u2014 before the <code>:</code>. Last three statements do not have the index of the argument. In fact there is nothing before the <code>:</code>. Both representations are valid.</li> <li>The <code>5d</code> after the <code>:</code> means that the width of the column used for printing must be at least 5.</li> <li>Lines 1 to 4 have spaces before them as the integer being printed has fewer than five characters.</li> </ul>"},{"location":"chapter-3/lesson-3.5/","title":"Lesson-3.5","text":""},{"location":"chapter-3/lesson-3.5/#lesson-35","title":"Lesson-3.5","text":""},{"location":"chapter-3/lesson-3.5/#library","title":"Library","text":"<p>We will look at two more libraries \u2014 <code>math</code> and <code>random</code> \u2014 and use them to solve some fascinating problems in mathematics.</p>"},{"location":"chapter-3/lesson-3.5/#math","title":"<code>math</code>","text":"<p>Consider the following sequence: $$ \\sqrt{2}, \\sqrt{2 + \\sqrt{2}}, \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}},\\ \\dots $$ Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value?</p> <pre><code>import math\nx = 0\nfor n in range(1, 6):\n    x = math.sqrt(2 + x)\n    print(f'n = {n}, x_n = {x:.3f}')\n</code></pre> <p>If we execute the above code, we get the following output:</p> <pre><code>n = 1, x_n = 1.414\nn = 2, x_n = 1.848\nn = 3, x_n = 1.962\nn = 4, x_n = 1.990\nn = 5, x_n = 1.998\n</code></pre> <p><code>sqrt()</code> is a function in the <code>math</code> library that returns the square root of the number that is entered as argument. Representing the output shown above as a table:</p> \\(n\\) \\(x_n\\) Approximate value 1 \\(\\sqrt{2}\\) 1.414 2 \\(\\sqrt{2 + \\sqrt{2}}\\) 1.848 3 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}\\) 1.962 4 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}\\) 1.990 5 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}}\\) 1.998 <p>Isn't that beautiful? It looks like this sequence \u2014 the train of square roots \u2014 is approaching the value 2. Let us run the loop for more number of iterations this time:</p> <pre><code>import math\nx = 0\nfor n in range(1, 20):\n    x = math.sqrt(2 + x)\nprint(x)\n</code></pre> <p>After just 20 iterations, the value is so close to two: <code>1.9999999999910236</code>. But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), then we terminate the iteration.</p> <pre><code>import math\nx_prev, x_curr = 0, math.sqrt(2)\ntol, count = 0.00001, 0\nwhile abs(x_curr - x_prev) &gt;= tol:\n    x_prev = x_curr\n    x_curr = math.sqrt(2 + x_prev)\n    count += 1\nprint(f'Value of x at {tol} tolerance is {x_curr}')\nprint(f'It took {count} iterations')\n</code></pre>"},{"location":"chapter-3/lesson-3.5/#random","title":"<code>random</code>","text":"<p>How do we toss a coin using Python?</p> <pre><code>import random\nprint(random.choice('HT'))\n</code></pre> <p>That is all there is to it! <code>random</code> is a library and <code>choice()</code> is a function defined in it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is nothing but a sequence of characters.</p> <p>We know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? Can we computationally verify if this is indeed the case? For that, we have to set up the following experiment. Toss a coin \\(n\\) times and count the number of heads. Dividing the total number of heads by \\(n\\) will give the empirical probability. As \\(n\\) becomes large, this probability must approach 0.5.</p> <pre><code>import random\nn = int(input())\nheads = 0\nfor i in range(n):\n    toss = random.choice('HT')\n    if toss == 'H':\n        heads += 1\nprint(f'P(H) = {heads / n}')\n</code></pre> <p>Let us run the above code for different values of \\(n\\) and tabulate our results:</p> \\(n\\) \\(P(H)\\) 10 0.2 100 0.52 1,000 0.517 10,000 0.5033 100,000 0.49926 1,000,000 0.499983 <p>The value is approaching <code>0.5</code> as expected! <code>random</code> is quite versatile.</p> <p>Exercise</p> <p>Let us now roll a dice! <code>randint(a, b)</code> returns a random integer \\(N\\) such that \\(a \\leq N \\leq b\\). </p> <pre><code>import random\nprint(random.randint(1, 6))\n</code></pre> <p>Now find the empirical probability for the numbers on each face of a die using this function.</p>"},{"location":"chapter-3/lesson-3.6/","title":"Lesson 3.6","text":""},{"location":"chapter-3/lesson-3.6/#lesson-36","title":"Lesson 3.6","text":""},{"location":"chapter-3/lesson-3.6/#math-and-programming","title":"Math and Programming","text":"<p>Before closing this chapter, let us spend some time at the intersection of mathematics and programming.</p>"},{"location":"chapter-3/lesson-3.6/#limits","title":"Limits","text":"<p>Consider the following number:</p> \\[ \\sqrt{2} - 1 \\] <p>It is known that \\(1 &lt; \\sqrt{2} &lt; 2\\). From this, it follows that \\(0 &lt; \\sqrt{2} - 1 &lt; 1\\). Now, consider the following sequence:</p> \\[ a_n = \\left( \\sqrt{2} - 1 \\right)^n \\] <p>As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically:</p> <pre><code>import math\nn = int(input())                # sequence length\nCONST = math.pow(2, 0.5) - 1    # basic term in the sequence\na_n = 1                         # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST           # computing the nth term\nprint(a_n)\n</code></pre> <p>Try this out for a few values of \\(n\\). For \\(n = 100\\), the value is \\(5.27 \\times 10^{-39}\\), which is so small that for all practical purposes, it is as good as zero. </p>"},{"location":"chapter-3/lesson-3.6/#recurrence-relation","title":"Recurrence relation","text":"<p>Now, here is another fact. For every number \\(n\\), there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ For \\(n = 1\\), this is obvious: \\(x = -1, y = 1\\). What about higher values of \\(n\\)? . We can prove this using mathematical induction. The following is a sketch of the inductive proof. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\), then: $$ (\\sqrt{2} - 1)^{n + 1} = (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ = (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ = x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} $$ The equation given above defines what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence we have \\(x_1 = -1, y_1 = 1\\). For \\(n &gt; 0\\), the pair of equations given below forms the recurrence relation: $$ \\begin{align} x_{n + 1} &amp;= 2 y_n - x_n\\ y_{n + 1} &amp;= x_n - y_n \\end{align} $$ Loops are useful tools when it comes to computing terms in such sequences:</p> <pre><code>n = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n - 1):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\n</code></pre>"},{"location":"chapter-3/lesson-3.6/#rational-approximation","title":"Rational Approximation","text":"<p>This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.</p>"},{"location":"chapter-4/lesson-4.1/","title":"Lesson-4.1","text":""},{"location":"chapter-4/lesson-4.1/#lesson-41","title":"Lesson-4.1","text":""},{"location":"chapter-4/lesson-4.1/#functions","title":"Functions","text":""},{"location":"chapter-4/lesson-4.1/#introduction","title":"Introduction","text":"<p>In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, \\(f(x) = x^2\\), is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much more richer than their mathematical counterparts. Let us quickly convert the mathematical function, \\(f(x) = x^2\\),  into a Python function:</p> <pre><code>def f(x):\n    y = x ** 2\n    return y\n</code></pre> <p>The code given above is called the definition of function <code>f</code>. <code>def</code> is the keyword used to define functions. <code>f</code> is the name of the function. <code>x</code> is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable <code>y</code> is returned. <code>return</code> is the keyword used for this purpose.</p> <p>If we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like:</p> <pre><code>def square(x):\n    y = x ** 2\n    return y\n\nprint(square(2))\n</code></pre> <p>The output is:</p> <pre><code>4\n</code></pre> <p><code>square(2)</code> is a function call. We use the name of the function, <code>square</code>, and pass the number 2 as an argument to it. The <code>x</code> in the function definition is called the parameter. The value that is passed to the function in the call is called the argument. This is a convention that we will follow throughout this lesson.</p> <p>A visual representation of the terms we have defined so far is given below:</p> <p></p> <p>A mental model to understand functions:</p> <ul> <li>Parameters can be thought of as the function's inputs.</li> <li>The body of the function can be pictured as the sequence of steps that transform the input into the output.</li> <li>The return statement can be thought of as a means of communicating the output to the rest of the code.</li> </ul>"},{"location":"chapter-4/lesson-4.1/#examples","title":"Examples","text":"<p>We will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions.</p> <ul> <li>Functions could have multiple parameters:</li> </ul> <pre><code># This function computes the area of a rectangle.\n# Length and breadth are the parameters\ndef area(l, b):\n    return l * b\n</code></pre> <ul> <li>Functions could have no parameters:</li> </ul> <pre><code>def foo():\n    return \"I don't like arguments visiting me!\"\n</code></pre> <ul> <li>Functions could have no return value:</li> </ul> <pre><code>def foo():\n    print(\"I don't like talking to the outside world!\")\n\nfoo()\n</code></pre> <p>When the code given above is executed, we get the following output:</p> <pre><code>I don't like talking to the outside world!\n</code></pre> <p>Note that we didn't have to type <code>print(foo())</code>. We just had to call the function \u2014 <code>foo()</code> \u2014 since it already has the print statement inside it. But what happens if we type <code>print(foo())</code>? We get the following output:</p> <pre><code>I don't like talking to the outside world!\nNone\n</code></pre> <p>If no explicit return statement is present in a function, <code>None</code> is the default value returned by it. When the interpreter comes across the <code>print(foo())</code> statement, first the function <code>foo()</code> is evaluated. This results in the first line of the output. Since <code>foo()</code> has no explicit return statement, it returns <code>None</code> by default. That is why the second line in the output is <code>None</code>.</p> <ul> <li>A minimal Python function looks like the one given below:</li> </ul> <pre><code>def foo():\n    pass\n</code></pre> <p><code>pass</code> is a keyword in Python. When the interpreter comes across a <code>pass</code> statement, it doesn't perform any computation and moves on to the next line. The reason this is minimal is because it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body. </p> <p>Such functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that they need to define a function to perform a specific task. But they might not know the exact details of the implementation or it may not be an urgent requirement. In such a scenario, they will add a minimal function like the one given above in their code and name it appropriately. Implementing this function will become a task on their to-do list and will be taken up as and when the need arises.</p> <ul> <li>Functions could have multiple return statements, but the moment the first return is executed, control exits from the function:</li> </ul> <pre><code>def foo():\n    return 1\n    return 2\n</code></pre> <p><code>foo()</code> will always return 1. Line 3 is redundant. An example of a function having multiple returns that are not redundant:</p> <pre><code>def evenOrOdd(n):\n    if n % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'\n\nprint(evenOrOdd(10))\nprint(evenOrOdd(11))\n</code></pre> <p>The output is:</p> <pre><code>even\nodd\n</code></pre> <p>When <code>evenOrOdd</code> is called with an even number as argument, the return statement in line 3 is executed. When the same function is called with an odd number as argument, the return statement in line 5 is executed.</p> <ul> <li>Functions could return multiple values:</li> </ul> <pre><code># Accept only positive floating point numbers\ndef bound(x):\n    lower = int(x)\n    upper = lower + 1\n    return lower, upper\n\ny = 7.3\nl, u = bound(y)\nprint(f'{l} &lt; {y} &lt; {u}')\n</code></pre> <p>The exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by <code>bound</code> is stored in <code>l</code> and the second value returned by <code>bound</code> is stored in <code>u</code>.</p> <ul> <li>Functions have to be defined before they can be called. The function call cannot come before the definition. For example:</li> </ul> <pre><code>##### Alarm! Wrong code snippet! #####\nprint(f(5))\n\ndef f(x):\n    return x ** 2\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>When the above code is executed, it throws a <code>NameError</code>. Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, <code>f</code> is a name that the interpreter has never seen before and therefore it throws a <code>NameError</code>. Recall that <code>NameError</code> occurs when we try to reference a name that the interpreter has not seen before.</p> <ul> <li>Function calls could be used in expressions:</li> </ul> <pre><code>def square(a):\n    return a ** 2\n\nx, y, z = int(input()), int(input()), int(input())\nif square(x) + square(y) == square(z):\n    print(f'{x}, {y} and {z} form the sides of a right triangle with {z} as the hypotenuse')\n</code></pre> <ul> <li>Function calls cannot be assigned values:</li> </ul> <pre><code>##### Alarm! Wrong code snippet! #####\ndef foo():\n    return True\n\nfoo() = 1\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>The above code throws a <code>SyntaxError</code>.</p> <ul> <li>Functions can be called from within other functions:</li> </ul> <pre><code>def foo():\n    print('I am inside foo')\n\ndef bar():\n    print('I am inside bar')\n    print('I am going to call foo')\n    foo()\n\nprint('I am outside both foo and bar')\nbar()\nprint('I am outside both foo and bar')\n</code></pre> <ul> <li>Functions can be defined inside other functions:</li> </ul> <pre><code>def foo():\n    def bar():\n        print('bar is inside foo')\n    bar()\n\nfoo()\n</code></pre> <p>Try calling <code>bar()</code> outside <code>foo()</code>. What do you observe?</p>"},{"location":"chapter-4/lesson-4.1/#docstrings","title":"Docstrings","text":"<p>Consider the following function:</p> <pre><code>def square(x):\n    \"\"\"Return the square of x.\"\"\"\n    return x ** 2\n</code></pre> <p>The string immediately below the function definition is called a docstring. From the Python docs:</p> <p>A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the <code>__doc__</code> special attribute of that object.</p> <p>Ignore unfamiliar terms such as \"module\" and \"class\". For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a life safer for other programmers reading your code.</p> <p>The docstring associated with a given function can be accessed using the <code>__doc__</code> attribute:</p> <pre><code>print(square.__doc__)\n</code></pre> <p>This gives <code>Return the square of x.</code> as output.</p>"},{"location":"chapter-4/lesson-4.2/","title":"Lesson-4.2","text":""},{"location":"chapter-4/lesson-4.2/#lesson-42","title":"Lesson-4.2","text":""},{"location":"chapter-4/lesson-4.2/#arguments","title":"Arguments","text":"<p>Python offers a number of options in terms of the way arguments can be passed to functions.</p>"},{"location":"chapter-4/lesson-4.2/#positional-arguments","title":"Positional arguments","text":"<p>All functions that we have seen so far have used positional arguments. Here, the position of an argument in the function call determines the parameter to which it is passed. Let us take the following problem:</p> <p> </p> <p>Write a function that accepts three positive integers <code>x</code>, <code>y</code> and <code>z</code>. Return <code>True</code> if the three integers form the sides of a right triangle with <code>x</code> and <code>y</code> as its legs and <code>z</code> as the hypotenuse, and <code>False</code> otherwise.</p> <p>Solution</p> <pre><code>def isRight(x, y, z):\n    if x ** 2 + y ** 2 == z ** 2:\n        return True\n    return False\n\nprint(isRight(3, 4, 5)) # 3 is passed to x, 4 is passed to y, 5 is passed to z\nprint(isRight(5, 4, 3)) # 5 is passed to x, 4 is passed to y, 3 is passed to z\n</code></pre> <p>The output is:</p> <pre><code>True\nFalse\n</code></pre> <p>Arguments are passed to the parameters of the function based on the position they occupy in the function call. Look at the comments in the above code to get a clear picture. Positional arguments are also called required arguments, i.e., they cannot be left out. Likewise, adding more arguments than there are parameters will throw an error. When positional arguments are involved, there should be exactly as many arguments in the function call as there are parameters in the function definition. Try to execute the following code and study the error message:</p> <pre><code>##### Alarm! Wrong code snippet!\nisRight(3, 4)\nisRight(3, 4, 5, 6)\n##### Alarm! Wrong code snippet!\n</code></pre>"},{"location":"chapter-4/lesson-4.2/#keyword-arguments","title":"Keyword arguments","text":"<p>Keyword arguments introduce more flexibility while passing arguments. Let us take up the same problem that we saw in the previous section and just modify the function calls:</p> <pre><code># The following is just a function call.\n# We are not printing anything here.\nisRight(x = 3, y = 4, z = 5)\n</code></pre> <p>The function call in line 3 uses what are known as keyword arguments. In this method, the names of the parameters are explicitly specified and the arguments are assigned to it using the <code>=</code> operator. This is different from positional arguments where the position of the argument in the function call determines the parameter to which it is bound. One advantage of using keyword arguments is that it reduces the possibility of entering the arguments in an incorrect order. For example: </p> <pre><code>isRight(3, 4, 5)    # intended call\nisRight(5, 4, 3)    # actuall call\nisRight(x = 3, y = 4, z = 5) # same as intended call\nisRight(z = 5, y = 4, x = 3) # same as intended call\n</code></pre> <p>Keyword arguments and positional arguments can be combined in a single call:</p> <pre><code>isRight(3, y = 4, z = 5)\n</code></pre> <p>Now try this out:</p> <pre><code>#### Alarm! Wrong code snippet! ####\nisRight(x = 3, 4, 5)\n#### Alarm! Wrong code snippet! ####\n</code></pre> <p>The interpreter throws a <code>TypeError</code> with the following message: <code>positional argument follows keyword arguments</code>. That is, in our function call, the positional arguments \u2014 <code>4</code> and <code>5</code> \u2014 come after the keyword argument <code>x = 3</code>. Why does the interpreter objects to this? Whenever both positional and keyword arguments are present in a function call, the keyword arguments must always come at the end. This is quite reasonable: positional arguments are extremely sensitive to position, so it is best to have them at the beginning.</p> <p>How about the following call?</p> <pre><code>#### Alarm! Wrong code snippet! ####\nisRight(3, x = 3, y = 4, z = 5)\n#### Alarm! Wrong code snippet! ####\n</code></pre> <p>The interpreter objects by throwing a <code>TypeError</code> with the following message: <code>isRight() got multiple values for argument x</code>. Objection granted! Another reasonable requirement from the Python interpreter: there must be exactly one argument in the function call for each parameter in the function definition, nothing more, nothing less. This could be a positional argument or a default argument, but not both.</p>"},{"location":"chapter-4/lesson-4.2/#default-arguments","title":"Default arguments","text":"<p>Consider the following scenario. The image that you see here is a map of your neighborhood. The grid lines are roads that can be used by cars. You wish to reach the point \\(P\\) from \\(O\\). There are no restrictions if you are on foot. The easiest way is to move along the line \\(OP\\). This is called the Euclidean distance between points \\(O\\) and \\(P\\). If you are in a car, then you are forced to move along the grid lines. The distance you would have to cover in a car is \\(OM + MP\\). This distance is called the Manhattan distance between points \\(O\\) and \\(P\\).</p> <p></p> <p>Let us say that a self-driving car startup operating in your neighborhood uses both these metrics while computing distances. Assume that its code base invokes the Euclidean distance 10 times and the Manhattan distance 1000 times. Since these metrics are used repeatedly, it is a good idea to represent them as functions in the code base:</p> <pre><code># Assume that O is the origin\n# All distances are computed from the origin\ndef euclidean(x, y):\n    return pow(x ** 2 + y ** 2, 0.5)\n\ndef manhattan(x, y):\n    return abs(x) + abs(y)\n</code></pre> <p>While the above code is fine, it ignores the fact that the Manhattan distance is being used hundred times more frequently compared to the Euclidean distance. Default arguments can come in handy in such situations:</p> <pre><code>def distance(x, y, metric = 'manhattan'):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\n</code></pre> <p>The parameter <code>metric</code> has <code>'manhattan'</code> as the default value. Let us try calling the function without passing any argument to the <code>metric</code> parameter:</p> <pre><code>print(distance(3, 4))\n</code></pre> <p>This gives <code>7</code> as the output. Since no value was provided in the function call, the default value of <code>'manhattan'</code> was assigned to the <code>metric</code> parameter. In the code base, wherever the Manhattan distance is invoked, we can just replace it with the function call <code>distance(x, y)</code>.</p> <p>The following points are important to keep in mind:</p> <ul> <li>Parameters that are assigned a value in the function definition are called default parameters.</li> <li>Default parameters always come at the end of the parameter list in a function definition.</li> <li>The argument corresponding to a default parameter is optional in a function call.</li> <li>An argument corresponding to a default parameter can be passed as a positional argument or as a keyword argument.</li> </ul> <p>Let us illustrate some of these points:</p> <pre><code>#### Alarm! Wrong code snippet! ####\ndef distance(metric = 'manhattan', x, y):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\n#### Alarm! Wrong code snippet! ####\n</code></pre> <p>The above code throws a <code>SyntaxError</code> with the following message: <code>non-default argument follows default argument</code>. In the function definition, the default parameter must always come at the end of the list of parameters. Now, for different ways of passing arguments in the presence of default parameters:</p> <pre><code>distance(3, 4)\ndistance(3, 4, 'manhattan')\ndistance(3, 4, metric = 'manhattan')\n</code></pre> <p>All three function calls are equivalent. The first one uses default value of <code>metric</code>. The second call explicitly passes <code>'manhattan'</code> as the metric using a positional argument. The last call explicitly passes <code>'manhattan'</code> as a keyword argument.</p>"},{"location":"chapter-4/lesson-4.2/#call-by-value","title":"Call by value","text":"<p>Consider the following code:</p> <pre><code>def double(x):\n    x = x * 2\n    return x\n\na = 4\nprint(f'before function call, a = {a}')\ndouble(a)\nprint(f'after function call, a = {a}')\n</code></pre> <p>The output is:</p> <pre><code>before function call, a = 4\nafter function call, a = 4\n</code></pre> <p>We see that the value of <code>a</code> is not disturbed by the function in any way. When the function call <code>double(a)</code> is invoked, the value in <code>a</code> is assigned to the parameter <code>x</code> in the function. Arguments are passed by assignment in Python, which means that something like <code>x = a</code> happens when <code>double(a)</code> is invoked. This kind of a function call where the value in a variable is passed as argument to the function is called call by value.</p> <p>Consider the following code:</p> <pre><code>def square(x):\n    return x * x\n\nx = 10\nx_squared = square(x)\n</code></pre> <p>We are using the same name for both the parameter of the function <code>square</code> and the argument passed to it. This is a bad practice. It is always preferable to differentiate the names of the parameters from the names of the arguments that are passed in the function call. This avoids confusion and makes code more readable. At this stage, you might be wondering how the variable <code>x</code> inside the function is related to the variable <code>x</code> outside it. This issue will be taken up in the next lesson on scopes. The above code could be rewritten as follows:</p> <pre><code>def square(num):\n    return num * num\n\nx = 10\nx_squared = square(x)\n</code></pre>"},{"location":"chapter-4/lesson-4.3/","title":"Lesson-4.3","text":""},{"location":"chapter-4/lesson-4.3/#lesson-43","title":"Lesson-4.3","text":""},{"location":"chapter-4/lesson-4.3/#scope","title":"Scope","text":"<p>Consider the following code:</p> <pre><code>def foo():\n    x = 1\n    print('This is a veritable fortress. None can enter here.')\n    print('\\N{smirking face}')\n\nfoo()\nprint(x)\n</code></pre> <p>This will give the following output:</p> <pre><code>This is a veritable fortress. None can enter here.\n\ud83d\ude0f\nTraceback (most recent call last):\n  File \"main.py\", line 7, in &lt;module&gt;\n    print(x)\nNameError: name 'x' is not defined\n</code></pre> <p>Why did the interpreter throw an an error in line-7? It tried to look for the name <code>x</code> and was unable to find it. But isn't <code>x</code> present in the function <code>foo</code>? Is the interpreter careless or are we missing something? The interpreter is never wrong! The region in the code where a name can be referenced is called its scope. If we try to reference a variable outside its scope, the interpreter will throw a <code>NameError</code>. </p>"},{"location":"chapter-4/lesson-4.3/#local-vs-global","title":"Local vs Global","text":"<p>In the above example, the scope of the name <code>x</code> is local to the function; <code>x</code> has a meaningful existence only inside the function and any attempt to access it from outside the function is going to result in an error. Think about functions as black holes: they don't let variables (light) escape the function's definition (event-horizon)! Let us take another example:</p> <pre><code>y = 10\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\n</code></pre> <p>The name <code>y</code> is accessible from within the function as well. We say that the scope of <code>y</code> is global. That is, it can be referenced from anywhere within the program \u2014 even inside a function \u2014 after it has been defined for the first time. There is a slight catch here: if another variable with the same name is defined within the function, then things change. We will take up this case later. </p> <p>At this stage, we are ready to formulate the rules for local and global variables [refer]:</p> <p>Local: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.</p> <p>Global: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.</p> <p>The scope of the parameters in the function definition are local. The following code will throw a <code>NameError</code> when executed:</p> <pre><code>def double(x):\n    x = x * 2\n    return x\n\ndouble(2)\nprint(x)\n</code></pre>"},{"location":"chapter-4/lesson-4.3/#examples","title":"Examples","text":"<p>Let us now look at few more examples that bring out some fine points regarding local and global scope:</p> <pre><code>### Variant-1\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\ny = 10\nfoo()\n</code></pre> <p>Notice the difference between this code and the one at the beginning of the earlier section. Here, the variable <code>y</code> is defined after the function definition, while in the earlier version <code>y</code> was defined before the function definition. But both versions give the same output. All that matters is for  <code>y</code> to be defined before the function call. What happens if <code>y</code> is defined after <code>foo</code> is called?</p> <pre><code>### Variant-2\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\ny = 10\n</code></pre> <p>This throws a <code>NameError</code> at line-5, which is reasonable as <code>y</code> is not defined in the main program before <code>foo</code> is called. The scope of <code>y</code> is still global; it can be referenced anywhere in the program once it has been defined.</p> <p>Now, let us crank up the difficulty level:</p> <pre><code>def foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\n</code></pre> <p>We have the same name \u2014 <code>x</code> \u2014 appearing inside the function and outside the function. Are they the same or different? Let us check the output:</p> <pre><code>x inside foo = 10\nx outside foo = 100\n</code></pre> <p>They are different! The <code>x</code> inside <code>foo</code> is different from the <code>x</code> outside <code>foo</code>. </p> <ul> <li>The scope of the name <code>x</code> inside <code>foo</code> is local; it is a local variable. This is because of the first rule: a variable that is assigned a value inside the function becomes a local variable. Since <code>x</code> is assigned a value in line-2, it becomes a local variable.</li> <li>The scope of the <code>x</code> outside <code>foo</code> is global. Though there is another <code>x</code> inside the function <code>foo</code>, that cannot be accessed outside the function.</li> </ul> <p>This may start to get a little confusing. How does Python internally manage local and global variables? For this, we will briefly turn to the concept of namespaces. This will give a different perspective to the problem of name resolution.</p>"},{"location":"chapter-4/lesson-4.3/#namespaces","title":"Namespaces","text":"<p>Consider the following snippet of code:</p> <pre><code>x = 1.0\navar = 'cool'\ndef foo():\n    pass\n</code></pre> <p>We have used three different names here: <code>x</code>, <code>avar</code> and <code>foo</code>. The first two names represent variables that store literals. The last name represents a function. How does the Python interpreter internally process these names? It uses a concept called namespaces. A namespace can be thought of as a lookup table \u2014 dictionary to be precise \u2014 that maps names to objects.</p> <p></p>"},{"location":"chapter-4/lesson-4.3/#globals","title":"globals()","text":"<p>There are different types of namespaces. The variables that we define in the main program are represented in the <code>globals</code> namespace. For example:</p> <pre><code>x = 1.0\navar = 'cool'\ndef foo():\n    y = 2.0\n\nfoo()\nprint(globals())\n</code></pre> <p>This returns the following output:</p> <p></p> <p>Ignore all the other details and just focus on the region highlighted in yellow. Notice that the names <code>x</code>, <code>avar</code> and <code>foo</code> are present in the namespace. <code>x</code>  and <code>avar</code> are mapped to the objects <code>1</code> and <code>cool</code> respectively, while <code>foo</code> is mapped to some complex looking object:  <code>&lt;function foo at 0x7f8ecd2aa1f0&gt;</code>. The number <code>0x7f8ecd2aa1f0</code> is the location in the memory where the function's definition is stored [refer]. There is another way to check whether a given name is in a namespace:</p> <pre><code>print('x' in globals())\nprint('avar' in globals())\nprint('foo' in globals())\n</code></pre> <p>All three lines result in <code>True</code>. </p>"},{"location":"chapter-4/lesson-4.3/#locals","title":"locals()","text":"<p>Notice something interesting in the previous code, the name <code>y</code> is not found in the <code>globals</code> namespace! We can verify this as follows:</p> <pre><code>print('y' in globals())\n</code></pre> <p>This results in <code>False</code>. Variables that are assigned a value inside a function are <code>local</code> to the function and cannot be accessed outside it. How does the Python interpreter handle names inside functions? It creates a separate namespace every time a function is called. This is called a local namespace. Now, consider the following code:</p> <pre><code>def foo():\n    y = 2.0\n    print('Is y in locals?', 'y' in locals())\n\nfoo()\nprint('Is y in globals?', 'y' in globals())\n</code></pre> <p>It returns the following output:</p> <pre><code>Is y in locals? True\nIs y in globals? False\n</code></pre>"},{"location":"chapter-4/lesson-4.3/#scope-and-namespaces","title":"Scope and Namespaces","text":"<p>For every function call, the interpreter creates a local namespace that contains all names and their corresponding objects that are defined in the function. Let us take an example:</p> <pre><code>def foo():\n    print(y)\n    print(locals())\n    x = 1\n    print(locals())\n\ny = 10\nfoo()\n</code></pre> <p>This gives the output:</p> <pre><code>10\n{}\n{'x': 1}\n</code></pre> <p>Since <code>y</code> is only being referenced inside <code>foo</code>, it doesn't become a part of the local namespace. It remains a global variable. Since <code>x</code> is being assigned a value inside <code>foo</code>, it is a local variable and therefore enters the local namespace. The moment control exits the function, the namespace corresponding to it is deleted.</p> <p>Whenever the interpreter comes across a name in a function it sticks to the following protocol:</p> <ul> <li>First peep into the local namespace created for that function call to see if the name is present in it. If it is present, then go ahead and use the value that this variable points to in the local namespace.</li> <li>If it is not present, then look at the global namespace. If it is present in the global namespace, then use the value corresponding to this name.</li> <li>If it is not present in the global namespace, then look into the <code>built-in</code> namespace. We will come back to the <code>built-in</code> namespace right at the end.</li> <li>If it is not present in any of these namespaces, then raise a <code>NameError</code>. </li> </ul> <p>The following image captures this idea. The <code>built-in</code> namespace has been ignored for now. Refer to the last section to get the complete image.</p> <p></p> <p>With this context, let us revisit the problem that we looked at the end of the first section:</p> <pre><code>def foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\n</code></pre> <p>When the function is called at line-6, the interpreter creates a local namespace for <code>foo</code>. At line-2, <code>x</code> becomes a part of this namespace. When <code>x</code> is referenced at line-3, the interpreter first looks at the local namespace for <code>foo</code>. Since <code>x</code> is present there, it is going to use the value corresponding to it - in this case <code>10</code>.  Once control exits the function, the local namespace corresponding to it is deleted. At line-7, the interpreter will replace the name <code>x</code> with the value <code>100</code> which is present in the global namespace.</p>"},{"location":"chapter-4/lesson-4.3/#global-keyword","title":"<code>global</code> keyword","text":"<p>Let us revisit the scope rules:</p> <p>Local: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.</p> <p>Global: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.</p> <p>Consider the following code:</p> <pre><code>def foo():\n    print(x)\n    x = x + 1\n\nx = 10\nfoo()\n</code></pre> <p>When the above code is executed, we get the following error: <code>UnboundLocalError: local variable 'x' referenced before assignment</code> [refer]. This code violates the first rule. <code>x</code> is being assigned a value in line-3 of the function; hence it becomes a local variable. At line-2 we are trying to reference a value that is yet to be defined. Note that the assignment statement in line-5 doesn't count as the <code>x</code> there is not local to <code>foo</code>, but is a global variable.</p> <p>But what if we want to reuse the global variable <code>x</code> inside the function <code>foo</code>? Python provides a keyword called <code>global</code> for this purpose:</p> <pre><code>def foo():\n    global x\n    print(f'x inside foo = {x}')\n    x = x + 1\n    print(f'x inside foo = {x}')\n\nx = 10\nprint(f'x outside foo = {x}')\nfoo()\n</code></pre> <p>The output is:</p> <pre><code>x outside foo = 10\nx inside foo = 10\nx inside foo = 11\n</code></pre> <p>By declaring <code>x</code> to be global inside <code>foo</code>, a new local variable <code>x</code> is not created even though it appears to the left of an assignment statement in line-4.</p>"},{"location":"chapter-4/lesson-4.3/#built-ins","title":"Built-ins","text":"<p>So far we have been freely using built-in functions like <code>print</code>, <code>int</code>, <code>input</code> and so on. At some level, these are also names in Python and these also get resolved during run-time. There is a separate namespace called <code>builtins</code> where these functions are defined. </p> <p>Consider the following code:</p> <pre><code>##### Never do something like this! #####\nprint = 1\n##### Never do something like this! #####\n</code></pre> <p>If the above code is executed, we don't get an error! This is somewhat surprising. But syntactically, there is nothing wrong here. But we will get into serious problems when we try to do the following:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nprint = 1\nprint(1)\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>This will throw a <code>TypeError</code>. The name <code>print</code> has been hijacked and is being used as an <code>int</code> variable. How does Python allow this to happen?</p> <p></p> <p>When resolving names, the built-in namespace is the last stage in the interpreter's journey. Syntactically, nothing prevents us from using the name of a built-in function, such as <code>print</code>, as the name of a variable. But this is a very bad practice that should be avoided at any cost!</p>"},{"location":"chapter-4/lesson-4.4/","title":"Lesson-4.4","text":""},{"location":"chapter-4/lesson-4.4/#lesson-44","title":"Lesson-4.4","text":""},{"location":"chapter-4/lesson-4.4/#function-calling-function","title":"Function calling Function","text":"<p>Consider the following program:</p> <pre><code>def first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n\nfirst()\n</code></pre> <p>When the code given above is executed, the output is as follows:</p> <pre><code>third\nsecond\nfirst\n</code></pre> <p>We have already seen that a function can be called from inside another function. In the code snippet given above, we have a slightly complex version. Let us try to understand this visually. This method of visualization is novel and is called the traffic-signal method. You will see why it has been christened this way.</p> <p>Consider a simple function which doesn't call any other function within its body. Most of the functions we have seen so far are like this. The call corresponding to this function could be in one of these two states: ongoing or completed.</p> <ul> <li>Ongoing if the control is inside the body of the function, executing one of its lines. </li> <li>Completed if all the lines in the body of the function have been executed and control has exited out of the function, either because a <code>return</code> statement was encountered or because the control reached the last line in the function, in which case <code>None</code> is returned by default.</li> </ul> <p>A function which calls another function inside it could find itself in one of the three states: ongoing, suspended or completed. They are color coded as follows. Now you see why it is called the traffic-signal theory:</p> <p></p> <p>Ongoing and completed have the same meaning. To understand the suspended state, consider the following diagrams that correspond to the code given above:</p> <p></p> <p>Each column here is called a stack. They all represent the same stack at different instants of time, i.e., the  columns here show the state of the stack at three different time instants. The horizontal arrow shows the passage of time. The vertical arrow indicates that each new function call gets added onto the top of the stack.</p> <p></p> <p>Re-introducing the code for reference:</p> <pre><code>def first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n\nfirst()\n</code></pre> <p>As <code>third()</code> doesn't call any other function, it never enters the suspended state. Line-10 is the first print statement to be executed; this is why we see <code>third</code> as the first entry in the output. The job of the function <code>third</code> is done and it turns red. Now, the call transfers to the most recent suspended function - <code>second</code>. The execution of <code>second</code> resumes from the point where it got suspended; the print statement at line-7 is executed following which <code>second</code> turns red. Finally, control transfers to <code>first</code>, the print statement at line-3 is executed and <code>first</code> turns red.</p>"},{"location":"chapter-4/lesson-4.4/#recursion","title":"Recursion","text":"<p>A recursive function is one which calls itself inside the body of the function. A typical example of recursion is the factorial function:</p> <pre><code>def fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n</code></pre> <p>In the <code>fact</code> function given above, when the interpreter comes to line-4, it sees a recursive call to <code>fact</code>. In such a case, it suspends or temporarily halts the execution of <code>fact(n)</code> and starts executing <code>fact(n - 1)</code>. Let us take a concrete example. This is what happens when <code>fact(4)</code> is called:</p> <p></p> <p>When <code>fact(0)</code> is called, there are no more recursive calls. This is because, the condition in line-2 evaluates to <code>True</code> and the value <code>1</code> is returned. This condition is called the base-case of the recursion. In the absence of a base-case, the recursion continues indefinitely and never terminates.</p> <p></p> <p>Once the base-case kicks in, <code>fact(0)</code> is done with its duty. So, the call transfers to the most recent suspended function. On the stack, we see that this is <code>fact(1)</code>. <code>fact(1)</code> now becomes active. When it returns the value <code>1</code>, its life comes to an end, so the control transfers to the most recent suspended function, which is <code>fact(2)</code>. This goes on until we reach <code>fact(4)</code>. When <code>fact(4)</code> returns the value <code>24</code>, all calls have been completed and we are done!</p>"},{"location":"chapter-4/lesson-4.4/#caution-in-recursion","title":"Caution in Recursion","text":"<p>This section discusses some finer aspects of recursion.</p>"},{"location":"chapter-4/lesson-4.4/#fibonacci-series","title":"Fibonacci series","text":"<p>Let us take another popular example, the Fibonacci series: $$ 1, 1, 2, 3, 5, 8, ... $$ Each term in this series is obtained by summing the two terms immediately to its left. We can mathematically express this as follows. If \\(x_1 = x_2 = 1\\), then for all \\(n &gt; 2, n \\in \\mathbb{N}\\), we have the following recurrence relation: $$ x_n = x_{n - 1} + x_{n - 2} $$ We can now compute the \\(n^{th}\\) term of the Fibonacci series using a recursive function:</p> <pre><code>def fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\n</code></pre> <p>Now, try calling <code>fibo(40)</code>. You will notice that it takes a very long time to compute the value. Why does this happen? This is because a lot of wasteful computation happens. Let us see why:</p> <p></p> <p>This is a different representation of the recursive computation and is called a recursion tree. Notice how some function calls appear multiple times. <code>fibo(3)</code>  and <code>fibo(1)</code> are being computed twice, <code>fibo(2)</code> is being computed thrice. For a larger value of <code>n</code> such as <code>50</code>, there would be even more wasteful computation.</p> <p>Practically, how can we estimate the time that it takes for this program to run? One way would be to sit in front of the computer with a stopwatch in hand. But that is so un-Pythonic. Thankfully, the <code>time</code> library provides a good solution to this problem:</p> <pre><code>import time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\n</code></pre> <p>In a standard Python repl, it takes almost a minute! Coming back to the problem of Fibonacci series, we see that naive recursion doesn't give us an efficient solution. We can instead look at the following iterative solution:</p> <pre><code>import time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    x_prev, x_curr = 1, 1\n    while n &gt; 2:\n        x_prev, x_curr = x_curr, x_prev + x_curr\n        n -= 1\n    return x_curr\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\n</code></pre> <p>Line-8 in the above code may be a little confusing. This is nothing but multiple assignment in the same line done simultaneously. The RHS of the assignment statement will be evaluated first, these two values will then be simultaneously assigned to their respective containers on the LHS. A better and more accurate explanation will be given in the next chapter when we discuss tuples.</p>"},{"location":"chapter-4/lesson-4.4/#counting-function-calls","title":"Counting Function Calls","text":"<p>How do we compute the number of times a function is called? We can do this using a global variable:</p> <pre><code>def fact(n):\n    global count\n    count = count + 1\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n\ncount = 0\nfact(4)\nprint(count)\n</code></pre> <p>This is one of the potential uses of global variables.</p>"},{"location":"chapter-4/lesson-4.4/#turtles-all-the-way-down","title":"Turtles all the way down","text":"<p>What happens if we have a recursive function without a base case? The simplest example of such a pathological function is:</p> <pre><code>##### Alarm! Bad code snippet! #####\ndef foo():\n    foo()\n##### Alarm! Bad code snippet! #####\n</code></pre> <p>When the above function is called with <code>foo()</code>, we get a <code>RecursionError</code> with the following message: <code>maximum recursion depth exceeded</code>. The limit is usually set to 1000 in most systems, i.e., If there are more than 1000 recursive calls, then that is going to result in this error. To verify what the limit is, you can run the following code:</p> <pre><code>import sys\nprint(sys.getrecursionlimit())\n</code></pre>"},{"location":"chapter-5/lesson-5.1/","title":"Lesson-5.1","text":""},{"location":"chapter-5/lesson-5.1/#lesson-51","title":"Lesson-5.1","text":""},{"location":"chapter-5/lesson-5.1/#lists","title":"Lists","text":""},{"location":"chapter-5/lesson-5.1/#introduction","title":"Introduction","text":"<p>A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nletters = ['a', 'b', 'c', 'd']\nwords = ['this', 'is', 'a', 'list']\n</code></pre> <ul> <li>Lists can be printed, just like the other types we have seen so far. <code>print(numbers)</code> will give the following output:</li> </ul> <pre><code>[1, 2, 3, 4, 5]\n</code></pre> <ul> <li>Lists could contain objects of different data types. Python permits lists such as this:</li> </ul> <pre><code>mixture = [1, 1.0, '1', True]\n</code></pre> <ul> <li>Lists have a separate data type - <code>list</code>. We can also check if a given variable holds an object of type <code>list</code>:</li> </ul> <pre><code>numbers = [1, 2, 3]\nprint(type(numbers))\nprint(isinstance(numbers, list))\n</code></pre> <ul> <li>The <code>len</code> function can be used to find the number of elements in a list:</li> </ul> <pre><code>numbers = [1, 2, 3]\nprint(f'This list has {len(numbers)} elements in it')\n</code></pre> <ul> <li>Lists support indexing and slicing. These two operations work exactly the same way as they did for strings:</li> </ul> <pre><code>numbers = [1, 2, 3, 4]\nprint(numbers[0], numbers[1], numbers[2], numbers[3])\nprint(numbers[1 : 3])\nprint(numbers[-2])\n</code></pre>"},{"location":"chapter-5/lesson-5.1/#iterating-through-lists","title":"Iterating through lists","text":"<p>As a list is a sequence, we can iterate through it using <code>for</code>. This is one of the primary uses of the <code>for</code> loop:</p> <pre><code># Method-1\nnumbers = [1, 2, 3, 4]\nfor num in numbers:\n    print(num)\n</code></pre> <p>The loop variable \u2014 <code>num</code> \u2014 picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a <code>while</code> loop:</p> <pre><code># Method-2\nnumbers = [1, 2, 3, 4]\nindex = 0\nwhile index &lt; len(numbers):\n    print(numbers[index])\n    index += 1\n</code></pre> <p>Finally, we can also use the <code>for</code> loop to iterate through the indices of the list. For this, we take the help of the <code>range</code> function.</p> <pre><code># Method-3\nnumbers = [1, 2, 3, 4]\nfor index in range(len(numbers)):\n    print(numbers[index])\n</code></pre> <p>In the example given above, <code>len(numbers)</code> is equal to <code>4</code>. So, the <code>range</code> sequence will be <code>0, 1, 2, 3</code>. <code>index</code> is the loop variable that iterates through this sequence.</p> <p>Methods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses <code>while</code>, while method-3 uses <code>for</code>. Method-1 stands out from the other two as it directly pulls elements from the sequence.</p>"},{"location":"chapter-5/lesson-5.1/#growing-a-list","title":"Growing a list","text":"<p>Lists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list:</p> <pre><code>list1 = []\nlist2 = list()\n</code></pre> <p>Both <code>list1</code> and <code>list2</code> are empty lists. The interpreter doesn't mind spaces between the opening and closing braces, so <code>list1 = [  ]</code>  also works. Given an empty list, how do we add items to it? Python provides two ways to do this:</p> <pre><code>list1 = list1 + [1]\nprint(list1)\nlist2 = list2.append(1)\nprint(list2)\n</code></pre> <p>Both lists end up having just the one element. The first method is called list concatenation, i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called <code>append</code> that is essentially a function defined for the <code>list</code> type. Append adds elements at the end of the list.</p> <p>Consider the following problem:</p> <p>Generate the list of positive integers less than 100 that are divisible by 3.</p> <p>There are at least two ways of doing this. The first one uses <code>while</code>:</p> <pre><code># Method-1\nnum = 3\nnums_div = []\nwhile num &lt; 100:\n    nums_div.append(num)\n    num += 3\n</code></pre> <p>The next method uses <code>for</code>:</p> <pre><code># Method-2\nnums_div = []\nfor num in range(3, 100, 3):\n    nums_div.append(num)\n</code></pre>"},{"location":"chapter-5/lesson-5.1/#operations-on-lists","title":"Operations on Lists","text":"<p>We have already seen how the <code>+</code> operator works with lists:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist12 = list1 + list2\nprint(list12)\nlist21 = list2 + list1\nprint(list21)\n</code></pre> <p>This gives the concatenated output:</p> <pre><code>[1, 2, 3, 4, 5, 6]\n[4, 5, 6, 1, 2, 3]\n</code></pre> <p>The order matters when two lists are being concatenated! The next is the <code>*</code> operator:</p> <pre><code>list1 = [0] * 5\nprint(list1)\nlist2 = [1, 2, 3] * 3\nprint(list2)\n</code></pre> <p>This replicates the list. The following is the output:</p> <pre><code>[0, 0, 0, 0, 0]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n</code></pre> <p>Two lists are equal if they have the same sequence of elements:</p> <pre><code>l1 = [1, 2, 3]\nl2 = [1, 2, 3]\nl3 = [3, 2, 1]\nprint(l1 == l2)\nprint(l2 == l3)\n</code></pre> <p>This results in:</p> <pre><code>True\nFalse\n</code></pre> <p>Finally, two lists can be compared with the <code>&gt;</code> or the <code>&lt;</code> operator. List comparison works very similar to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter:</p> <p>Lexicographic ordering</p> <p>First element from both lists are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second element of both the lists are compared. This process continues until either list is exhausted.</p> <p>Some example comparisons:</p> <pre><code>print([1, 2] &lt; [2, 1])\nprint([1] &lt; [1, 2, 3])\nprint([2, 3, 4] &lt; [3])\nprint([] &lt; [1])\n</code></pre> <p>All four of them result in <code>True</code>. </p>"},{"location":"chapter-5/lesson-5.1/#useful-functions","title":"Useful Functions","text":"<p>Let us look at some built-in functions that operate on lists:</p> <ul> <li><code>sum</code>: this is used to find the sum of the elements in a list of numbers:</li> </ul> <pre><code>a = [1, 2, 3]\nprint(sum(a))\n</code></pre> <ul> <li><code>max</code> and <code>min</code>: these two functions find the maximum and minimum value in a list respectively.</li> </ul> <pre><code>a = [1, 2, 3]\nprint(min(a), max(a))\n</code></pre> <p>What happens if <code>a</code> is a list of strings? What would <code>max(a)</code> and <code>min(a)</code> produce?</p> <ul> <li><code>sorted</code>: this function returns a sorted list</li> </ul> <pre><code>a = [2, 1, 3]\nprint(sorted(a))\n</code></pre> <p>We have come across the <code>range</code> object and seen how useful it was in iterating through a sequence. So far <code>range</code> has been associated with the <code>for</code> loop. Its time has come to break out of the loopy prison:</p> <pre><code>numbers = range(10)\nprint(numbers)\n</code></pre> <p>This gives <code>range(0, 10)</code> as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list:</p> <pre><code>numbers = list(range(10))\nprint(numbers)\n</code></pre> <p>This gives <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code> as the output.</p>"},{"location":"chapter-5/lesson-5.2/","title":"Lesson-5.2","text":""},{"location":"chapter-5/lesson-5.2/#lesson-52","title":"Lesson-5.2","text":""},{"location":"chapter-5/lesson-5.2/#lists","title":"Lists","text":""},{"location":"chapter-5/lesson-5.2/#mutability","title":"Mutability","text":"<p>Consider the following problem:</p> <p>Assume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague's turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the \"0\" key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter \"O\" instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter \"O\" with the number 0. I leave it to your imagination to decide who won the finals!</p> <p>Solution</p> <pre><code>runs = [1, 4, 2, 'O', 4, 'O'] # the data for one over is given here\nprint(runs)\nfor i in range(len(runs)):\n    if runs[i] == 'O':\n        runs[i] = 0\nprint(runs)\n</code></pre> <p>The most interesting line is the fifth one: <code>runs[i] = 0</code>. We are updating a list in-place. Python permits this operation because lists are mutable. Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1)\nprint(list2)\n</code></pre> <p>Both give the same output even though we are only modifying <code>list2</code> in-place!</p> <pre><code>[100, 2, 3]\n[100, 2, 3]\n</code></pre> <p>What is happening here? To understand this, we will take the help of a built-in function called <code>id</code>. Every object in Python has a unique identity: if <code>x</code> is an object, then <code>id(x)</code> returns this object's identity. From the Python documentation, \"this is guaranteed to be unique among simultaneously existing objects\". In the implementation of the Python that we use, this unique <code>id</code> is nothing but the object's memory address.</p> <p></p> <p>In line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the <code>is</code> keyword:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1 is list2)\n</code></pre> <p>This prints <code>True</code>. Now consider another scenario:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nprint(list1 == list2)\nprint(list1 is list2)\n</code></pre> <p>This gives the following output:</p> <pre><code>True\nFalse\n</code></pre> <p>This because equality and identity are two different things. In the code, line-3 checks for equality of two lists, line-4 checks if the two lists point to the same object. <code>list1</code> and <code>list2</code> point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal.</p> <p>How do we create a copy of a list so that updating one doesn't end up changing both? Python provides three ways to do this:</p> <pre><code>list1 = [1, 2,  3]\nlist2 = list(list1)\nlist3 = list1[:]\nlist4 = list1.copy()\n\nlist2[0] = 100\nlist3[0] = 200\nlist4[0] = 300\n\nprint(list1, list2, list3, list4)\nprint(list1 is not list2, list1 is not list3, list1 is not list4)\n</code></pre> <p>This results in the following output:</p> <pre><code>[1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3]\nTrue True True\n</code></pre> <ul> <li>In line-2, we pass <code>list1</code> as an argument to the <code>list</code> function which returns a new list object with the same sequence of elements as <code>list1</code>. </li> <li>In line-3, we are slicing the list. Slicing a list results in a new list object. As no <code>start</code> or <code>stop</code> values are mentioned, they are going to default to <code>0</code> and <code>len(list1)</code> respectively. So, the entire list is returned. However, it is a brand new object. </li> <li>In line-4, we use a method call <code>copy</code> that is defined for the <code>list</code> object.</li> </ul> <p>Lines 10 and 11 verify that the methods used to copy lists in lines 2, 3 and 4 actually work.</p>"},{"location":"chapter-5/lesson-5.2/#call-by-reference","title":"Call by reference","text":"<p>Mutability impacts the way lists are handled in functions. Consider these two snippets:</p> <pre><code># Snippet-1\ndef foo():\n    L.append(1)\n\nL = [0]\nprint(f'L before: {L}')\nfoo()\nprint(f'L after: {L}')\n</code></pre> <p><code>Snippet-1</code> doesn't have any parameters. Since <code>L</code> is not being assigned a new value inside <code>foo</code>, the scope of <code>L</code> remains global.</p> <pre><code># Snippet-2\ndef foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(L)\nprint(f'L after: {L}')\n</code></pre> <p><code>Snippet-2</code> has <code>L_foo</code> as a parameter whose scope is local to <code>foo</code>. But note that modifying <code>L_foo</code> within the function changes <code>L</code> outside the function. This is because, <code>L_foo</code> and <code>L</code> point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: <code>L_foo = L</code>, so <code>L_foo</code> is just another name that refers to the object that <code>L</code> is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed. </p> <p>If all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don't want these side effects? We have to create a new list object like we did before:</p> <pre><code>def foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(list(L))\nprint(f'L after: {L}')\n</code></pre> <p><code>foo</code> doesn't produce any side effects. Line-7 could be replaced with <code>foo(L[:])</code> or <code>foo(L.copy())</code>.</p>"},{"location":"chapter-5/lesson-5.3/","title":"Lesson-5.3","text":""},{"location":"chapter-5/lesson-5.3/#lesson-53","title":"Lesson-5.3","text":""},{"location":"chapter-5/lesson-5.3/#lists","title":"Lists","text":""},{"location":"chapter-5/lesson-5.3/#simulating-an-ipl-innings","title":"Simulating an IPL Innings","text":"<p>Let us return to the problem of recording the number of runs scored in every ball of an IPL match. A typical innings of a T20 match has 20 overs, each over having 6 balls. Let us assume that all balls bowled are fair deliveries that do not concede any extras, a rather liberal assumption. This leaves us with exactly 120 numbers that we need to record, all lying between 0 and 6. How can this information be stored in a Python program that makes it suitable for further processing? A list is a good candidate.</p> <p>Let us now simulate an innings. For this, we take the help of the <code>random</code> library:</p> <pre><code>import random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], k = 120)\nprint(type(runs))\nprint(len(runs))\n</code></pre> <p><code>choices</code> is a function in the <code>random</code> library. It uniformly samples from the seven numbers (0 to 6) given in the input list with replacement. If that sounded too cryptic, this is what it does:</p> <ul> <li>Pick a number from the list <code>[0, 1, 2, 3, 4, 5, 6]</code> at random.  Each of the seven numbers is equally likely to be picked.</li> <li>Add this to the output list. The original list remains undisturbed, i.e., we are not moving an element from the input list to the output list, we are only copying it.</li> <li>Repeat this process 120 times.</li> </ul> <p>Let us verify if the counts are approximately the same:</p> <pre><code>for run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\n</code></pre> <p><code>runs.count(run)</code> returns the number of times the element <code>run</code> appears in the list <code>runs</code>. <code>count</code> is a method defined for the <code>list</code> type. This gives the following output:</p> <pre><code>0 appears 19 times\n1 appears 20 times\n2 appears 19 times\n3 appears 16 times\n4 appears 18 times\n5 appears 11 times\n6 appears 17 times\n</code></pre> <p>The counts are quite close. But this is not very practical:</p> <ul> <li><code>5</code> runs are seldom observed in cricket matches.</li> <li><code>0</code>, <code>1</code> and <code>2</code> are much more common than <code>3</code>, <code>4</code> and <code>6</code>.</li> </ul> <p>We can give our preferences using a weights keyword-argument:</p> <pre><code>import random\n# choices is distributed over multiple lines\n# this is done to improve readability\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nfor run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\nprint(f'Total number of runs scored = {sum(runs)}')\n</code></pre> <p>This gives the following output:</p> <pre><code>0 appears 32 times\n1 appears 34 times\n2 appears 32 times\n3 appears 7 times\n4 appears 12 times\n5 appears 0 times\n6 appears 3 times\nTotal number of runs scored = 185\n</code></pre> <p>We have used <code>sum(runs)</code> to get the sum of the elements in the list. <code>sum</code> is a built-in function. The way to understand the <code>weights</code> keyword-argument is using the following table:</p> Run Weight 0 30 1 30 2 20 3 5 4 10 5 0 6 5 Total 100 <p>The weight is the importance given to a run. From the table given above, we see that 0 and 1 occur 30% of the times, 6 occurs 5% of the times and so on. <code>choices</code> function will keep this distribution in mind while picking up items from the input-list.</p> <p>Let us now start analyzing this innings. We have already seen how to count the number of occurrences of singles, doubles, fours and sixes. What about the first occurrence of a six? In which ball was the first six scored?</p> <pre><code>first_six_ball = runs.index(6) + 1\nprint(first_six_ball)\n</code></pre> <p><code>index</code> is a method that accepts an element as input and returns the first occurrence of this element in the list. For example, <code>runs.index(6)</code> returns the first index where a six occurs  in the list <code>runs</code>. Since the number of balls is one more than the index,  <code>1</code> has been added. What happens if we pass an input that is not present in the list:</p> <pre><code>first_five_ball = runs.index(5)\nprint(first_five_ball)\n</code></pre> <p>In this case, <code>5</code> never occurs in the list. So this throws a <code>ValueError</code> with the following message: <code>5 is not in list</code>. One must be careful while using the <code>index</code> method. We could have done this using another method:</p> <pre><code>for ball, run in enumerate(runs):\n    if run == 6:\n        print(f'The first six was hit at ball number {ball + 1}')\n        break\n</code></pre> <p>The <code>enumerate</code> object can be very handy when we want to access both the element and its index while iterating through a list. The enumerate object yields pairs: <code>(index, list[index])</code>. In some sense, we have two loop variables: the first is the index of the element in the list while the second is the element itself. Coming back to cricket, what if we want to find the number of balls it took to score the last 50 runs in the innings? It would be easier to reverse the list and then iterate through it:</p> <pre><code>balls = 0\nlast_runs = 0\nfor run in reversed(runs):\n    last_runs += run\n    balls += 1\n    if last_runs &gt;= 50:\n        print(f'It took {balls} balls to score the last 50 runs.')\n        break\n</code></pre> <p>The <code>reversed</code> object helps us iterate through the list in the reversed order. Note that it doesn't make any changes to the original list. One final question: we wish to find if the batsmen have run three runs at any point in the match. We don't want to know at which point in the innings this has happened.</p> <pre><code>three_existence = 3 in runs\nprint(three_existence)\n</code></pre> <p>Recall that we used the <code>in</code> keyword to check for the presence of one string in another. Something similar is happening here. The code given above prints <code>True</code> if 3 is an element in <code>runs</code> and <code>False</code> otherwise.</p>"},{"location":"chapter-5/lesson-5.4/","title":"Lesson-5.4","text":""},{"location":"chapter-5/lesson-5.4/#lesson-54","title":"Lesson-5.4","text":""},{"location":"chapter-5/lesson-5.4/#lists","title":"Lists","text":""},{"location":"chapter-5/lesson-5.4/#list-methods","title":"List Methods","text":""},{"location":"chapter-5/lesson-5.4/#insert","title":"<code>insert</code>","text":"<p>We have looked at list methods like <code>append</code>, <code>count</code> and <code>index</code> so far. There are some more interesting methods that will come in handy. <code>insert</code> can be used to insert an element in a list at a given position:</p> <pre><code>L = [1, 1, 2, 3, 8]\nL.insert(4, 5)\nprint(L)\n</code></pre> <p><code>list.insert(index, object)</code> inserts the <code>object</code> before <code>index</code> in the <code>list</code>. In the code given above, the element <code>5</code> is inserted before the index <code>4</code> in the list <code>L</code>. Let us try a few more inserts:</p> <pre><code>L = [10, 20, 30]\nL.insert(0, 5)          # L becomes [5, 10, 20, 30]\nL.insert(2, 15)         # L becomes [5, 10, 15, 20, 30]\nL.insert(4, 25)         # L becomes [5, 10, 15, 20, 25, 30]\nL.insert(len(L), 35)    # L becomes [5, 10, 15, 20, 25, 30, 35]\nL.insert(20, 40)        # L becomes [5, 10, 15, 20, 25, 30, 35, 40]\n</code></pre> <p>If the index is greater than the length of the current list, then the element gets added to the end. <code>insert</code> is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using <code>append</code>.</p>"},{"location":"chapter-5/lesson-5.4/#pop","title":"<code>pop</code>","text":"<p>Consider the following code:</p> <pre><code>L = ['a', 'b', 'c', 'd', 'e', 'f']\nindex = 1\nx = L.pop(index)\nprint(f'The element {x} at index {index} was removed from the list')\nprint(f'The current list is {L}')\n</code></pre> <p><code>L.pop(index)</code> removes the element at <code>index</code> in <code>L</code> and returns it. If no argument is provided to <code>pop</code>, <code>index</code> defaults to -1. <code>index</code> is thus a default argument for the method <code>pop</code>. A default value of -1 means that the last element in the list is removed. To see this an action, execute the following code:</p> <pre><code>L = ['a', 'b', 'c', 'd', 'e', 'f']\nx = L.pop()\nprint(f'The current list is {L}')\n</code></pre> <p>What happens if you enter an <code>index</code> that is out of range?</p>"},{"location":"chapter-5/lesson-5.4/#reverse","title":"<code>reverse</code>","text":"<p>A list can be reversed in-place using the following method:</p> <pre><code>L = [1, 2, 3, 4, 5]\nprint('Before:', L, id(L))\nL.reverse()\nprint('After:', L, id(L))\n</code></pre> <p>It is called in-place because the list before and after have the same <code>id</code>, i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this:</p> <pre><code>L = [1, 2, 3, 4, 5]\nL = L.reverse()\nprint(L)\n</code></pre> <p>This prints <code>None</code>, which is expected as <code>reverse</code> doesn't return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following:</p> <pre><code>L = [1, 2, 3, 4, 5]\nL_reversed = L.copy()\nL_reversed.reverse()\nprint('Original list:', L)\nprint('Reversed list:', L_reversed)\n</code></pre> <p>Why did we have to make a copy in line-2?</p>"},{"location":"chapter-5/lesson-5.4/#sort","title":"<code>sort</code>","text":"<p>Another useful method is <code>sort</code> which is used to sort lists in-place:</p> <pre><code>L = [2, 1, 5, 6, 4, 3]\nprint('Before', L)\nL.sort()\nprint('After', L)\n</code></pre> <p>Though this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms.</p>"},{"location":"chapter-5/lesson-5.4/#remove","title":"<code>remove</code>","text":"<p>Now for some destructive functions:</p> <pre><code>L = [1, 2, 3, 4, 5] * 2\nprint('Before', L)\nL.remove(1)\nprint('After', L)\n</code></pre> <p><code>L.remove(x)</code> removes the first (leftmost) occurrence of the element <code>x</code> in the list <code>L</code>. Trying to remove an element that is not there in the list will raise a <code>ValueError</code> with the message <code>list.remove(x): x not in list</code>. A safe way to remove items is as follows:</p> <pre><code># x is the item to be removed; L is the list\nif x in L:\n    L.remove(x)\n</code></pre> <p>How is <code>remove</code> different from <code>pop</code>?</p>"},{"location":"chapter-5/lesson-5.4/#stack","title":"Stack","text":"<p>A list along with the methods <code>append</code> and <code>pop</code> simulate a data structure called stack. A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out.</p> <pre><code># Start with an empty stack\nstack = [ ]\n# Append items to end of the stack; also called a push operation\nstack.append('Harry Potter and the Philosopher\\'s Stone')\nstack.append('Harry Potter and the Chamber of Secrets')\n# State of the stack \nprint(stack)\n# Remove items from the end of the stack; also called a pop operation\nstack.pop()\n# State of the stack\nprint(stack)\n</code></pre>"},{"location":"chapter-5/lesson-5.4/#queue","title":"Queue","text":"<p>A list along with the methods <code>insert</code> and <code>pop</code> simulate a data structure called queue. A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue, is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First in First Out.</p> <pre><code># Start with an empty queue\nqueue = [ ]\n# Insert elements at the beginning of the queue\nqueue.insert(0, 'Customer-1')\nqueue.insert(0, 'Customer-2')\n# State of the queue\nprint(queue)\n# Remove items from the queue\nqueue.pop()\n# State of the queue\nprint(queue)\n</code></pre>"},{"location":"chapter-5/lesson-5.4/#strings-and-lists","title":"Strings and Lists","text":""},{"location":"chapter-5/lesson-5.4/#split","title":"<code>split</code>","text":"<p>Lists make a frequent appearance while processing strings. Consider the following problem:</p> <p>Accept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence.</p> <p>Let us look at a \"list-less\" solution first:</p> <p>Solution-1</p> <pre><code>sentence = 'this sentence is false' # a simple sentence\ncount = 1\nfor char in sentence:\n    if char == ' ':\n        count += 1\nprint(count)\n</code></pre> <p>We just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can't be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists.</p> <p>Solution-2</p> <pre><code>sentence = 'this sentence is false' # a simple sentence\nwords = sentence.split(' ')         # space is the delimiter used\ncount = len(words)\nprint(count)\n</code></pre> <p><code>split</code> is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the <code>split</code> operation is a list of strings that are split along the delimiter. If we print the list <code>words</code>, we get the following list: <code>['this', 'sentence', 'is', 'false']</code>. Let us take another example:</p> <pre><code>comma_words = 'one,two,three,four'\nnumbers = comma_words.split(',')\nprint(numbers)\n</code></pre> <p>We get <code>['one', 'two', 'three', 'four']</code> as the output. Note that we have specified <code>','</code> as the delimiter. The delimiter is not limited to characters, it can be any string. For example:</p> <pre><code>some_string = 'allISwell'\nwords = some_string.split('IS')\nprint(words)\n</code></pre> <p>The output is: <code>['all', 'well']</code>. </p>"},{"location":"chapter-5/lesson-5.4/#join","title":"<code>join</code>","text":"<p>Just as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem:</p> <p>Accept a sequence of words as input and construct a sentence out of it.</p> <p>We will first look at a solution that doesn't use lists:</p> <p>Solution-1</p> <pre><code>words = ['this', 'sentence', 'is', 'false']\nsentence = ''\nfor word in words:\n    sentence += word + ' '\nprint(sentence)\n</code></pre> <p>Though this solution seems correct, it is wrong by one character! Print the last character in the sentence:</p> <pre><code>print(sentence[-1])\n</code></pre> <p>It is not the letter <code>e</code> but a space. We ended up printing an extra space at the end. This might seem trivial, but programming is all about precision.  A better solution is given below:</p> <p>Solution-2</p> <pre><code>words = ['this', 'sentence', 'is', 'false']\nsentence = words[0]\nfor word in words[1 : ]:\n    sentence += ' ' + word\nprint(sentence)\n</code></pre> <p>This is more accurate. But it seems clumsy as we had to iterate from the second word in the list. The final solution uses a simple method and is quite sophisticated.</p> <p>Solution-3</p> <pre><code>words = ['this', 'sentence', 'is', 'false']\nsentence = ' '.join(words)\nprint(sentence)\n</code></pre> <p>Isn't that a thing of beauty! Just as <code>split</code> chops a string along a delimiter, <code>join</code> stitches together the strings in a list, and the thread it uses is a space in this case. We could also stitch them together using any other string, let us use a comma instead:</p> <pre><code>words = ['one', 'two', 'three']\nsentence = ','.join(words)\nprint(sentence)\n</code></pre> <p>This output is <code>one,two,three</code>. The stitching seems too tight. Let us give it some space:</p> <pre><code>words = ['one', 'two', 'three']\nsentence = ', '.join(words)\nprint(sentence)\n</code></pre> <p>Notice the space after the comma. The output is <code>one, two, three</code>.</p>"},{"location":"chapter-5/lesson-5.5/","title":"Lesson-5.5","text":""},{"location":"chapter-5/lesson-5.5/#lesson-55","title":"Lesson-5.5","text":""},{"location":"chapter-5/lesson-5.5/#lists","title":"Lists","text":""},{"location":"chapter-5/lesson-5.5/#nested-lists","title":"Nested Lists","text":"<p>Recall the <code>runs</code> list that we generated with the help of the <code>random</code> library:</p> <pre><code>import random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nassert len(runs) == 120\n</code></pre> <p>An <code>assert</code> statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line-5 of the code given above, we are making sure that the length of the list is <code>120</code>. This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the <code>assert</code> keyword is <code>True</code>, then control transfers to the next line. If it is <code>False</code>, the interpreter raises an <code>AssertionError</code>.</p> <p>Let us look at a different way of organizing the information contained in <code>runs</code>:</p> <pre><code>overs = list()\nnew_over = list()\nfor ball, run in enumerate(runs):\n    new_over.append(run)\n    if (ball + 1) % 6 == 0:\n        overs.append(new_over)\n        new_over = list()\n</code></pre> <p><code>overs</code> is a nested list, which is nothing but a list of lists. Each element in <code>overs</code> corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively.</p> <pre><code>assert len(overs) == 20\nfor over in overs:\n    assert len(over) == 6\n</code></pre> <p>With this representation in place, how many runs were scored in the fourth ball of the third over?</p> <pre><code>answer = overs[2][3]    # zero-indexing\nprint(answer)\n</code></pre> <p>The first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself:</p> <pre><code>third_over = overs[2]\nprint(third_over)\nfourth_ball = third_over[3]\nprint(fourth_ball)\nassert fourth_ball == overs[2][3]\n</code></pre>"},{"location":"chapter-5/lesson-5.5/#matrices","title":"Matrices","text":"<p>Matrices are 2D objects. We can represent them as nested lists. Let us first populate a \\(3 \\times 3\\) matrix of zeros:</p> <p></p> <pre><code>mat = [ ]\nfor i in range(3):\n    mat.append([ ])     # we are appending an empty list\n    for _ in range(3):\n        mat[i].append(0)\nprint(mat)\n</code></pre> <p>This gives the following output:</p> <pre><code>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n</code></pre> <p>Do you find anything odd in line-4? We have used <code>_</code> as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use the <code>_</code> to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix:</p> <pre><code>mat = [ ]\nnum = 1\nfor i in range(3):\n    mat.append([ ])\n    for _ in range(3):\n        mat[i].append(num)\n        num += 1\nprint(mat)\n</code></pre> <p>This gives the following output:</p> <pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n</code></pre> <p>The code given above to construct this matrix could be written in the following manner as well:</p> <pre><code>mat = [ ]\nnum = 1\nfor _ in range(3):\n    row = [ ]\n    for _ in range(3):\n        row.append(num)\n        num += 1\n    mat.append(row)\nprint(mat)\n</code></pre>"},{"location":"chapter-5/lesson-5.5/#shallow-and-deep-copy","title":"Shallow and Deep Copy","text":"<p>Consider the following code:</p> <pre><code>mat1 = [[1, 2], [3, 4]]\nmat2 = mat1\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\n</code></pre> <p>We already know what will happen here. Lists are mutable. <code>mat2</code> is just an alias for <code>mat1</code> and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn't modify the other. Let us try one of them:</p> <pre><code>mat2 = mat1.copy()\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\n</code></pre> <p>No problems so far. But try this:</p> <pre><code>mat1 = [[1, 2], [3, 4]]\nmat2 = mat1.copy()\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\n</code></pre> <p>This is the output we get:</p> <pre><code>[[100, 2], [3, 4]]\n[[100, 2], [3, 4]]\n</code></pre> <p>What is happening here? <code>mat1</code> has also changed! Wasn't <code>copy</code> supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case <code>copy</code> just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in <code>mat1</code> and <code>mat2</code> are still the same objects:</p> <pre><code>print(mat1[0] is mat2[0])\nprint(mat1[1] is mat2[1])\n</code></pre> <p>Both lines print <code>True</code>. In order to make a copy where both the inner and outer lists are new objects, we turn to deepcopy:</p> <pre><code>from copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\n</code></pre> <p>This gives the output:</p> <pre><code>[[1, 2], [3, 4]]\n[[100, 2], [3, 4]]\n</code></pre> <p>Finally we have two completely different objects:</p> <pre><code>from copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nprint(mat1 is not mat2)\nprint(mat1[0] is not mat2[0])\nprint(mat1[1] is not mat2[1])\n</code></pre> <p>All three print <code>True</code>! <code>deepcopy</code> is a function from the library <code>copy</code>. We won't enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use <code>deepcopy</code> if you wish to make a clean copy.</p>"},{"location":"chapter-5/lesson-5.6/","title":"Lesson-5.6","text":""},{"location":"chapter-5/lesson-5.6/#lesson-56","title":"Lesson-5.6","text":""},{"location":"chapter-5/lesson-5.6/#tuples","title":"Tuples","text":""},{"location":"chapter-5/lesson-5.6/#introduction","title":"Introduction","text":"<p>A tuple is an immutable sequence of values:</p> <pre><code>family = ('father', 'mother', 'child')\nprint(type(family))\nprint(isinstance(family, tuple))\n</code></pre> <p>Tuples share a close resemblance to lists. They can be indexed and sliced just like lists:</p> <pre><code>print(family[0])\nprint(family[:2])\n</code></pre> <p>The main point of difference between lists and tuples is that tuples cannot be updated in-place since they are immutable. So, the following operation will throw an error:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nnumbers = ('one', 'two', 'four')\nnumbers[2] = 'three'\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>The interpreter throws a <code>TypeError</code> with the following message: <code>TypeError: 'tuple' object does not support item assignment</code>. As a consequence, we cannot append or insert elements into a tuple. Likewise, elements in a tuple cannot be deleted. <code>count</code> and <code>index</code> are the only two methods which are defined for <code>tuple</code> and they carry the usual meaning:</p> <pre><code>numbers = (1, 2, 3, 1, 1)\nprint(numbers.count(1))\nprint(numbers.index(2))\n</code></pre> <p>We can iterate through a tuple using <code>for</code>:</p> <pre><code>for num in (1, 2, 3):\n    print(num)\n</code></pre> <p>Since tuples are immutable, they are passed by value in functions similar to other immutable types such as strings and numbers. As for functions that operate on tuples, <code>sum</code>, <code>max</code>, <code>min</code> are useful ones.</p>"},{"location":"chapter-5/lesson-5.6/#more-on-tuples","title":"More on Tuples","text":"<p>A few more points on tuples. </p> <ul> <li>A singleton tuple should be defined as follows:</li> </ul> <pre><code>i_am_single = (1, )\nprint(len(i_am_single))\nprint(isinstance(i_am_single, tuple))\n</code></pre> <p>Note the presence of a comma after the element. Let us see what happens if it is removed:</p> <pre><code>i_am_single = (1)\nprint(isinstance(i_am_single, int))\n</code></pre> <p>It is an integer!</p> <ul> <li>A list can be converted into a tuple and vice versa:</li> </ul> <pre><code>a_list = [1, 2, 3]\na_tuple = tuple(a_list)\nb_tuple = (1, 2, 3)\nb_list = list(b_tuple)\n</code></pre> <ul> <li>A tuple can hold a non-homogeneous sequence of items:</li> </ul> <pre><code>a_tuple = (1, 'cool', True)\n</code></pre> <ul> <li>Membership can be determined using the <code>in</code> keyword:</li> </ul> <pre><code>1 in (1, 2, 3)\n'hello' not in ('some', 'random', 'sequence')\n</code></pre> <ul> <li>Tuples can be nested:</li> </ul> <pre><code>a = ((1, 2, 3), (4, 5, 6))\nprint(a[0][2])\n</code></pre> <ul> <li>A tuple can hold mutable objects. </li> </ul> <pre><code>a_tuple = ([0, 1, 2], [4, 5, 6])\na_tuple[0][0] = 100\n</code></pre> <p>The code given above runs without any errors. But we are trying to update the tuple in line-2. Aren't tuples immutable? Though <code>a_tuple</code> is immutable, the element inside it is mutable. In any case, we aren't trying to change the sequence of objects inside the tuple, i.e., <code>a_tuple[0]</code> continues to point to the same object. Let us verify this:</p> <pre><code>a_tuple = ([0, 1, 2], [4, 5, 6])\nprint(id(a_tuple[0]))\na_tuple[0][0] = 100\nprint(id(a_tuple[0]))\n</code></pre> <p>We see that the <code>id</code> of the element inside the tuple remains unchanged. Thus the identities of the sequence of objects that make up a tuple can never change, and the interpreter will never allow that to change. If the objects inside the sequence are mutable \u2014 such as lists \u2014 then the values that they hold might change, but they continue to retain their identities.</p>"},{"location":"chapter-5/lesson-5.6/#lists-and-tuples","title":"Lists and Tuples","text":"<p>We have seen the close kinship between lists and tuples. Here is a brief summary that highlights the points of agreement and disagreement:</p> List Tuple Mutable Immutable <code>L = [1, 2, 3]</code> <code>T = (1, 2, 3)</code> Supports indexing and slicing Supports indexing and slicing Supports item assignment Doesn't support item assignment Supported methods: <code>count, index, append, insert, remove, pop</code>  and others Supported methods: <code>count, index</code> To get a list: <code>list(obj)</code> To get a tuple: <code>tuple(obj)</code> <p>The partnership between lists and tuples is quite interesting and can be explored further with another example.</p> <p>Populate a list that contains all ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.</p> <p>Solution</p> <pre><code>pairs = [ ]\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            pairs.append((a, b))\nprint(pairs)\n</code></pre> <p><code>pairs</code> is a list of tuples. We could have stored each pair as a list. But a tuple is the better choice here since the two elements in the pair have a well defined relationship and we don't want to accidentally modify them.</p>"},{"location":"chapter-5/lesson-5.6/#packing-and-unpacking","title":"Packing and Unpacking","text":"<p>At first sight, tuples might seem redundant members in the Python family, but they do occupy a significant place. For that, we have to look at tuples in more detail. Consider the following code:</p> <pre><code>T = 1, 2, 3\nprint(T)\nprint(isinstance(T, tuple))\n</code></pre> <p>At first sight, line-1 seems to be an error. We have seen multiple assignment on the same line, perhaps we are two variables short on the LHS? But on execution, we see that there is no error. <code>T</code> is in fact the tuple <code>(1, 2, 3)</code>. This is called tuple packing. The values <code>1</code>, <code>2</code> and <code>3</code> are packed into a tuple. The reverse operation is called sequence unpacking:</p> <pre><code>x, y, z = T\nprint(x, y, z)\n</code></pre> <p>Here, the tuple <code>T</code> is unpacked into the corresponding variables <code>x</code>, <code>y</code> and <code>z</code>. This is the principle behind multiple assignment. From the Python documentation, we have refer</p> <p>Multiple assignment is a combination of tuple packing and sequence unpacking.</p> <pre><code>x, y, z = 1, 2, 3\n</code></pre> <p>In the line given above, the RHS is first packed into a tuple and the sequence is then unpacked into the variables <code>x</code>, <code>y</code> and <code>z</code>. But why does the unpacking operation have the qualifier sequence before it? This is because any sequence can be unpacked:</p> <pre><code>l1, l2, l3, l4 = 'good'         # string\nnum1, num2, num3 = [1, 2, 3]    # list\nb1, b2 = (True, False)          # tuple\nx, y, z = range(3)              # range\n</code></pre> <p>That's fun! The same operations are invoked when multiple values are returned from functions:</p> <pre><code>def max_min(a, b):\n    if a &gt; b:\n        return a, b\n    return b, a\n\nx = max_min(1, 2)\nprint(x)\nprint(isinstance(x, tuple))\n</code></pre> <p>We see that <code>x</code> is a tuple. In the return statements at lines 3 and 4, multiple values are packed into tuples. So, the function is essentially returning a tuple.</p>"},{"location":"chapter-6/lesson-6.1/","title":"Lesson-6.1","text":""},{"location":"chapter-6/lesson-6.1/#lesson-61","title":"Lesson-6.1","text":""},{"location":"chapter-6/lesson-6.1/#dictionaries","title":"Dictionaries","text":""},{"location":"chapter-6/lesson-6.1/#introduction","title":"Introduction","text":"<p>Let us assume that we want to store the following information in Python:</p> Country Capital Brazil Brasilia Russia Moscow India New Delhi China Beijing South Africa Cape Town <p>A minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [refer]. </p> <p>Coming back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRICS nations and their capitals:</p> <pre><code>brics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n}\n</code></pre> <p>A dictionary is a collection of key-value pairs. In the code given above, <code>brics</code> is a dictionary. It has countries mapped to their respective capitals. For instance, <code>'India'</code> is mapped to <code>'New Delhi'</code>. Here, <code>'India'</code> is the key and <code>'New Delhi'</code> is the value. That is, the country is the key and its capital is the value. A dictionary object is of type <code>dict</code>:</p> <pre><code>print(type(brics))\nprint(isinstance(brics, dict))\n</code></pre> <p>To access the value corresponding to a given key, we do the following:</p> <pre><code>print(brics['India'], 'is the capital of', 'India')\nprint(brics['China'], 'is the capital of', 'China')\n</code></pre> <p>The value corresponding to a given key can be updated:</p> <pre><code># Moving to a different capital for South Africa\nbrics['South Africa'] = 'Pretoria'\n# Or we could also store all three capitals\nbrics['South Africa'] = ('Pretoria', 'Cape Town', 'Bloemfontein')\n</code></pre> <p>New key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this <code>brics</code>, so let us create a new dictionary called <code>globe</code> which starts off as a copy of <code>brics</code>. Recall the <code>copy()</code> method that we used to copy lists. A similar method is defined for dictionaries:</p> <pre><code>brics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n        }\nglobe = brics.copy()\nglobe['Spain'] = 'Madrid' \n</code></pre> <p>Adding a new key-value pair is as simple as the statement given in line 9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example:</p> <pre><code>some_dict = {'key_1': 0, 'key_2': 0}\n</code></pre> <p>Trying to access a key that is not present in the dictionary will result in a <code>KeyError</code>:</p> <pre><code>##### Alarm! Wrong code snippet! ######\nsome_dict = {'0': 'zero', '1': 'one'}\nprint(some_dict[0])\n##### Alarm! Wrong code snippet! ######\n</code></pre>"},{"location":"chapter-6/lesson-6.1/#more-examples","title":"More Examples","text":"<p>The key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: <code>int</code>, <code>str</code>, <code>float</code>, <code>bool</code>:</p> <pre><code># int &lt;&gt; int\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n# str &lt;&gt; int\nmonths = {'Jan': 31, 'March': 31, 'May': 31, 'Nov': 30}\n# int &lt;&gt; str\nroll_numbers = {1: 'CS001', 2: 'CS002', 3: 'CS003'}\n# str &lt;&gt; str\nnames = {'Rohit': 'Sharma', 'Saina': 'Nehwal'}\n# str &lt;&gt; float\nconstants = {'pi': 3.14, 'e': 2.71}\n# float &lt;&gt; str\nfractions = {0.5: 'half', 0.25: 'quarter', 0.3: 'one-third'}\n# int &lt;&gt; bool\nbinary = {0: True, 1: False}\n</code></pre> <p>Next, we have dictionaries that have <code>list</code> and <code>tuple</code> as the type of their values:</p> <pre><code># str &lt;&gt; list\noutcomes = {'IND VS AUS': ['IND', 'AUS', 'IND', 'IND'], 'IND VS ENG': ['IND', 'ENG']}\n# float &lt;&gt; tuple\nbounds = {1.7: (1, 2), 4.3: (4, 5), -1.2: (-2, -1)}\n</code></pre> <p>Tuples can be keys, provided they don't contain any mutable objects within them:</p> <pre><code># tuple &lt;&gt; list\nT1, T2 = (0, 1), (1, 2)\nrandom_numbers = {T1: [0.1, 0.4, 0.9], T2: [1.1, 1.9]}\n</code></pre> <p>Towards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example:</p> <pre><code># mixed\nreport_card = {\n                'name': 'Ramanujan',\n                'age': 18,\n                'school': 'KV',\n                'marks': (75, 80, 60, 95, 100)\n              }\n</code></pre>"},{"location":"chapter-6/lesson-6.1/#more-on-keys","title":"More on Keys","text":"<p>Earlier, we have mentioned that the keys of dictionaries have to be immutable, but this statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key? </p> <pre><code>##### Alarm! Wrong code snippet #####\nsome_list = [0, 1]\nbad_dict = {some_list: 0}\n##### Alarm! Wrong code snippet #####\n</code></pre> <p>It throws a <code>TypeError</code> with the following message: <code>unhashable type: 'list'</code>. A list cannot be a key in a dictionary; but the error message doesn't talk about immutability, instead it says that the <code>list</code> type is unhashable. A more accurate statement about keys in a dictionary is given below:</p> <p>The keys of a dictionary must be hashable.</p> <p>To understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped.</p>"},{"location":"chapter-6/lesson-6.1/#hash-tables","title":"Hash Tables","text":"<p>Python dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present.  This is where the idea of a hash function comes in.  The hash function is denoted by \\(h\\) and converts the key to the row number.</p> <p>The hash function accepts a key \\(k\\) as input and returns a value, \\(h(k)\\), as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point.</p> <p>Now, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>. Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example:</p> <pre><code>##### Alarm! Wrong code snippet #####\nsome_tuple = ([0, 1], [2, 3])\nbad_dict = {some_tuple: 0}\n##### Alarm! Wrong code snippet #####\n</code></pre> <p>Though <code>some_tuple</code> is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, <code>some_tuple</code> is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs.</p>"},{"location":"chapter-6/lesson-6.1/#iterating-over-dictionaries","title":"Iterating over Dictionaries","text":"<p>We can iterate over the keys of a dictionary:</p> <pre><code>squares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares.keys():\n    print(f'The square of {key} is {squares[key]}')\n</code></pre> <p><code>squares.keys()</code> returns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the <code>keys</code> method.</p> <pre><code>squares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares:\n    print(f'The square of {key} is {squares[key]}')\n</code></pre> <p>We can also iterate over the key-value pairs in a dictionary:</p> <pre><code>squares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key, value in squares.items():\n    print(f'The square of {key} is {value}')\n</code></pre>"},{"location":"chapter-6/lesson-6.1/#growing-a-dictionary","title":"Growing a Dictionary","text":"<p>An empty dictionary can be defined in one of the following ways:</p> <pre><code>D1 = dict()\nD1[0] = 1\nD2 = { }\nD2[0] = 1\n</code></pre> <p>Let us now solve the following problem:</p> <p> </p> <p>Ceate a dictionary from a list of words that maps words to their lengths.</p> Solution <pre><code>words = ['interstellar', 'dunkirk', 'inception', 'tenet']\nlengths = dict()\nfor word in words:\n    lengths[word] = len(word)\nprint(lengths)\n</code></pre> <p>A piece of trivia: what is common among the words in the list <code>words</code>? </p>"},{"location":"chapter-6/lesson-6.1/#mutability","title":"Mutability","text":"<p>Like lists dictionaries are mutable objects. To see the mutability of <code>dict</code> objects in action, consider the following code:</p> <pre><code>dict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is dict_2)\n</code></pre> <p>We see that <code>dict_2</code> is alias of <code>dict_1</code> and both point to the same object. If we want a new <code>dict</code> object with the same contents as <code>dict_1</code>, we could either use the <code>copy()</code> method or the <code>dict</code> built-in function:</p> <pre><code>dict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1.copy()      # dict(dict_1) also works\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\n</code></pre> <p>The last line prints <code>True</code> which confirms that we have two different objects. So modifying one doesn't affect the other. But note that <code>copy()</code> only produces a shallow copy. As long as the values are immutable, this doesn't matter. But if we have mutable values, then we have a problem:</p> <pre><code>dict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = dict_1.copy()\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is dict_2['one'])\n</code></pre> <p>Here, we see that the value corresponding to the key <code>'one'</code> in both dictionaries gets affected. This is because <code>dict_1['one']</code> and <code>dict_2['one']</code> are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy:</p> <pre><code>from copy import deepcopy\ndict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = deepcopy(dict_1)\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is not dict_2['one'])\n</code></pre>"},{"location":"chapter-6/lesson-6.2/","title":"Lesson-6.2","text":""},{"location":"chapter-6/lesson-6.2/#lesson-62","title":"Lesson-6.2","text":""},{"location":"chapter-6/lesson-6.2/#text-processing","title":"Text processing","text":"<p>The following paragraph is an excerpt from a talk given by Guido. The full text can be found here. </p> <p>In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it.</p> <p>Text processing plays an important role in analyzing text data. Given a piece of text, the following are some of the basic questions that we can ask:</p> <ul> <li>How many sentences are there in the text?</li> <li>How many words are there in the text?</li> <li>How many of them are unique?</li> <li>Which word appears the most number of times?</li> </ul> <p>Are these meaningful questions to ask? Do they lead us anywhere? Yes, they do! Consider the task of classifying articles. Some sample categories could be: lifestyle, science and technology, literature, films. If we want to understand what category an article falls under, one way to go about it is to read the entire article. We can do it for one or two articles, but what if we have to do this for hundreds of them? A better solution would be to computationally process each article, find the top five most common words and use that to get an idea of what the text is about.</p> <p>We could program a solution to do exactly this. In the next few sections, we will gradually write, one step at a time, the code that answers all of the above questions. Follow along with an IDE or text editor of your choice and run the code at each step. Let's start off by storing the string in a variable <code>text</code>.</p> <pre><code>text = \"In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it.\"\n</code></pre>"},{"location":"chapter-6/lesson-6.2/#number-of-sentences","title":"Number of sentences","text":"<p>Sentences could end with one of the following tokens: full stop, exclamation mark or question mark. For simplicity, let us assume that all sentences in our text ends with a full stop. We can split the string using full stop as a delimiter to get a list of sentences:</p> <p></p><pre><code>sentences = text.split('.')\n</code></pre> Let's now look into the list using some temporary code. It's very important as a programmer to know what your code is doing and printing out the contents of your variables will give a good look of what's happening. <pre><code># Prints one sentence in each line\nfor sentence in sentences:\n    print(sentence)\nprint(f'There are {len(sentences)} sentences in this text.')\n</code></pre>"},{"location":"chapter-6/lesson-6.2/#output","title":"Output","text":"<pre><code>In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers\nThe reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops\nIn fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it\n\nThere are 4 sentences in this text.\n</code></pre> <p>Notice that there are only three sentences, but we get the output to be four in the last line. On closer inspection, we see that <code>sentences[-1]</code> is not a sentence but an empty string. This is because, when a string is split using a delimiter which is present in the string, two substrings get generated, one to the left of the delimiter and the other to its right. As the full stop is the last character in the text, the substring to its right is an empty string. One way to correct this is to remove all empty strings in <code>sentences</code>:</p> <pre><code>while '' in sentences:\n    sentences.remove('')\nprint(f'There are {len(sentences)} sentences in this text.')    \n</code></pre>"},{"location":"chapter-6/lesson-6.2/#output_1","title":"Output","text":"<pre><code>There are 3 sentences in this text.\n</code></pre> One problem solved!"},{"location":"chapter-6/lesson-6.2/#number-of-words","title":"Number of words","text":"<p>To get the number of words, we can split each sentence by space:</p> <pre><code>words = [ ]\nfor sentence in sentences:\n    words_ = sentence.split(' ')    # words_ contains words in sentence\n    words.extend(words_)            # words is the collection of all words\n</code></pre> <p>If we print out <code>len(words)</code>, we get the number of words to be 86. Is that correct? wordcounter.net claims that there are 82 words in this text. Clearly, something is wrong with our code. Let us print each word along with its index in separate lines and see what we have:</p> <pre><code>for index, word in enumerate(words):\n    print(index, word)\n</code></pre> <p>Sifting through the output, we notice the following offenders:</p> <pre><code>11 \u2014\n23 \n49\n67 \u2014\n</code></pre> <p>Indices 11 and 67 are em dashes (\u2014) while 23 and 49 correspond to empty strings. Since we have two different characters to remove, let us clean up the list in the following way:</p> <pre><code>proc_words = [ ]\nfor word in words:\n    if not(word == '' or word == '\u2014'):\n        proc_words.append(word)\nprint(f'There are {len(proc_words)} words in this text')\n</code></pre> <p>And we have 82 words as expected. One more problem solved!</p>"},{"location":"chapter-6/lesson-6.2/#number-of-unique-words","title":"Number of Unique Words","text":"<p>You might be wondering why this lesson has come under Chapter 6 if there are no dictionaries floating around. This section will assuage that worry, because we will now use a dictionary to keep track of the number of unique words along with their frequency.</p> <pre><code>uniq_words = dict()\nfor word in proc_words:\n    if word not in uniq_words:\n        uniq_words[word] = 0\n    uniq_words[word] += 1\nprint(f'There are {len(uniq_words)} unique words in this text')\n</code></pre> <p>Apparently, there are 62 unique words in our text. Upon manual inspection, the word \"programmers\" occurs four times in the text. What does our dict have to say?</p> <pre><code>print(uniq_words['programmers'])\n</code></pre> <p>We get <code>2</code> as the output, another wrong answer! Programming doesn't seem like magic after all. We are making mistakes far too often. Note that this is not the exception, but the norm. The nice part of making mistakes is that they are almost always an opportunity to learn something. An error in the code is hidden knowledge, an insight into a flaw in our logic that we are yet to unmask. Now, back to the drawing board. Let us search for all entries in the list <code>proc_words</code> that have the substring \"programmers\" in them:</p> <pre><code>for word in proc_words:\n    if 'programmers' in word:\n        print(word)\n</code></pre>"},{"location":"chapter-6/lesson-6.2/#output_2","title":"Output","text":"<pre><code>programmers\nprogrammers,\nprogrammers\nprogrammers,\n</code></pre> <p>So, the problem is with the special character: comma.</p> <p>Another problem is introduced by the capitalization of words, usually at the beginning of sentences. Now that the problems have been identified, let us go ahead and fix them. Of course, this means we have to go back and modify the code we have already written. This is a perfectly normal process in programming - You start writing your solution, you gain a new insight in the process, you go back and change what you had just written (or sometimes even throw away the whole thing and start from scratch!). Let's now generate <code>proc_words</code> the right way:</p> <pre><code>proc_words = [ ]\nfor word_ in words:\n    word = word_.lower()\n    if not(word == '' or word == '\u2014'):\n        if not word_.isalnum():\n            word = word_[:-1]\n        proc_words.append(word)\nprint(f'There are {len(proc_words)} words in this text')\n</code></pre> <p>Several things are happening here. In line 12, every word is converted to lower case. In line , em dashes and empty strings are being ignored. Line 14 checks if a word contains a special character. If it does, then it is unburdened of that dangling character in line 15. Here we assume that special characters usually appear at the end of the word. In this text, there are two cases: \"programmers,\" and \"reason:\". All processed words are finally added to <code>proc_words</code> in line 16. Now that we have a cleaned up <code>proc_words</code>, we can go back and generate <code>uniq_words</code>:</p> <pre><code>uniq_words = dict()\nfor word in proc_words:\n    if word not in uniq_words:\n        uniq_words[word] = 0\n    uniq_words[word] += 1\nprint(f'There are {len(uniq_words)} unique words in this text')\n</code></pre> <p>Lovely! There are 58 unique words in the text. We can check if this is right by printing all the words and their counts:</p> <pre><code>for word, freq in uniq_words.items():\n    print(word, freq)\n</code></pre> <p>We can see that there is no erroneous repetition of any word. As a test, we can also see if the sum of the counts gives back the total number of words:</p> <pre><code>total = 0\nfor word in uniq_words:\n    total += uniq_words[word]\nassert total == len(proc_words)\n</code></pre> <p>As the code doesn't raise any <code>AssertionError</code>, we are correct!</p>"},{"location":"chapter-6/lesson-6.2/#frequent-words","title":"Frequent Words","text":"<p>Now onto the last problem - let us find the top three most frequently occurring words:</p> <pre><code>first_word = second_word = third_word = ''\nfirst_val = second_val = third_val = 0\nfor word, freq in uniq_words.items():\n    if freq &gt; first_val:\n        first_val, second_val, third_val = freq, first_val, second_val\n        first_word, second_word, third_word = word, first_word, second_word\n    elif freq &gt; second_val and freq &lt; first_val:\n        second_val, third_val = freq, second_val\n        second_word, third_word = word, second_word\n    elif freq &gt; third_val and freq &lt; second_val:\n        third_val = freq\n        third_word = word\nprint(first_word, first_val)\nprint(second_word, second_val)\nprint(third_word, third_val)\n</code></pre>"},{"location":"chapter-6/lesson-6.2/#output_3","title":"output","text":"<pre><code>the 6\nprogrammers 4\nin 3\n</code></pre> <p>We see that \"programmers\" is the second most frequent word. First and third most frequent words are \"the\" and \"in\" respectively. Such common words are called stop-words. If they are removed from the text,  \"programmers\" becomes the most frequent non-trivial word. So, without reading this text, one can guess that it should be something about programmers, thanks to Python!</p>"},{"location":"chapter-6/lesson-6.2/#summary","title":"Summary","text":"<p>The main takeaway from this lesson is the kind of mistakes we made and the way we fixed each one of them. In almost every problem, we started off with a solution, then tested it. We figured out that something was wrong, so we went back and tried to fix the problem.</p>"},{"location":"chapter-6/lesson-6.3/","title":"Lesson-6.3","text":""},{"location":"chapter-6/lesson-6.3/#lesson-63","title":"Lesson-6.3","text":""},{"location":"chapter-6/lesson-6.3/#dictionaries","title":"Dictionaries","text":""},{"location":"chapter-6/lesson-6.3/#pangrams-and-dictionaries","title":"Pangrams and Dictionaries","text":"<p>Assume that we wish to compute the following mapping between letters of the English alphabet and numbers from 1 to 26:</p> Letter Number a 1 b 2 ... ... z 26 <p>Each letter in the alphabet is mapped to a unique number from 1 to 26. In the table given above, the mapping is a simple linear mapping: <code>'a'</code> is mapped to <code>1</code>, <code>'b'</code> to <code>2</code> and so on. This mapping can be computed in the most uninteresting and lousy way given below:</p> <pre><code>mapping = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n           'f': 6 , 'g': 7, 'h': 8, 'i': 9, 'j': 10, \n           'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n           'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n           'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25,\n           'z': 26\n          }\n\nfor letter, count in mapping.items():\n    print(letter, count)\n</code></pre> <p>Phew! If you type the whole thing out, it will take you two full dull minutes. Your finger will curse you for the mechanical key-presses while your eyes will chide you for staring at the screen without blinking. You could cheese your way past the challenge by hitting the clipboard button and pasting it but will you really open up this textbook everytime you need to make this mapping?</p> <p>Let us try a roundabout but interesting way. Consider the following line:</p> <p>the quick brown fox jumps over the lazy dog</p> <p>This sentence is called a pangram. A pangram is a sentence that uses all the letters of the alphabet. Does that ring any bell?</p> <pre><code>pangram = 'the quick brown fox jumps over the lazy dog'\nwords = pangram.split(' ')          # get list of words in the sentence\nletters = ''.join(words)            # join the words back; eliminates spaces\nsorted_letters = sorted(letters)    # sort letters\nmapping, count = dict(), 0\nfor letter in sorted_letters:\n    # check if letter is not present in dict\n    # to avoid counting same letter multiple times\n    if letter not in mapping:\n        count += 1\n        mapping[letter] = count     # map the letter to count\n\nfor letter, count in mapping.items():\n    print(letter, count)\n</code></pre> <p>Plenty of things to learn from those 14 lines of code. Not all diversions are bad. Now that we have an interesting dictionary in place, let us jump into some methods that are bundled along with <code>dict</code>.</p>"},{"location":"chapter-6/lesson-6.3/#dictionary-methods","title":"Dictionary Methods","text":"<p>We have already seen <code>keys</code> and <code>items</code>. Both these are methods that return a view object over which we can iterate. According to the Python documentation, </p> <p>[View objects] provide a dynamic view on the dictionary's entries, which means that when the dictionary changes, the view reflects these changes.</p> <pre><code>keys = mapping.keys()\nprint(keys)\n</code></pre> <p>This gives the following output:</p> <pre><code>dict_keys(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\n</code></pre> <p>Using the <code>list()</code> function, both the <code>keys</code> and <code>items</code> views can be converted into lists:</p> <pre><code>keys_list = list(mapping.keys())\nprint(keys)\nitems_list = list(mapping.items())\nprint(items)\n</code></pre> <p>The output is as follows:</p> <pre><code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12), ('m', 13), ('n', 14), ('o', 15), ('p', 16), ('q', 17), ('r', 18), ('s', 19), ('t', 20), ('u', 21), ('v', 22), ('w', 23), ('x', 24), ('y', 25), ('z', 26)]\n</code></pre> <p><code>keys_list</code> is a list of keys in the dictionary <code>mapping</code>. <code>items_list</code> is a list of tuples, where each tuple is a key-value pair. Another useful method is <code>values</code>. This returns a view on the values:</p> <pre><code>view = mapping.values()\nview_list = list(view)\n</code></pre> <p>All three views - <code>keys</code>, <code>items</code>, <code>values</code> - support membership tests:</p> <pre><code>print('a' in mapping.keys())\nprint(1 in mapping.values())\nprint(('a', 1) in mapping.items())\n</code></pre> <p>All three return <code>True</code>. Membership tests for keys can be done in a simpler way:</p> <pre><code>print('a' in mapping)\nprint('x' in mapping)\nprint('ab' not in mapping)\n</code></pre> <p>Note that we dropped the <code>keys</code> method and it still worked! Now, to delete a key from a dictionary, we use the familiar <code>pop</code> method:</p> <pre><code>mapping['ab'] = 3           # some noise added to mapping\nvalue = mapping.pop('ab')\nprint(value)\nprint('ab' not in mapping)\n</code></pre> <p>If <code>key</code> is a key in a dictionary <code>D</code>, <code>D.pop(key)</code> removes the key <code>key</code> in <code>D</code> and returns the value associated with it. Removing a key naturally removes the value associated with it. Dictionaries are aristocratic data structures: keys are higher up in the hierarchy and values depend on the keys for their existence.</p>"},{"location":"chapter-6/lesson-6.4/","title":"Lesson-6.4","text":""},{"location":"chapter-6/lesson-6.4/#lesson-64","title":"Lesson-6.4","text":""},{"location":"chapter-6/lesson-6.4/#dictionaries-in-action-lms","title":"Dictionaries in Action: LMS","text":"<p>The online degree portal \u2014 our virtual classroom \u2014 is called a learning Management system (LMS). In more accessible terms, an LMS is the software application that powers the portal. Have you ever wondered how your assignment submissions get recorded and graded? This is the question that we will try to answer in this lesson. At a high level, the LMS is made of two components: frontend and backend.</p> <p></p> <p>As a user, your communicate with the frontend. The frontend is the website where you see all the content displayed. When you make an action, say clicking the submit button in a graded assignment, that action is fed to the backend as input. The backend processes this input and returns some output to the frontend, which is then displayed as the outcome of your action. Where does Python come into the picture? It features prominently in the backend.</p> <p>So how do we expect grading to work? It needs two inputs. The assignment and the submission corresponding to this assignment. It will return the result as output:</p> <p></p> <p>The grader can be expressed as a function:</p> <pre><code>def grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    return result\n</code></pre> <p>The function is incomplete. We need to decide how an assignment and its corresponding submission are going to be modeled.</p>"},{"location":"chapter-6/lesson-6.4/#assignment-model","title":"Assignment Model","text":"<p>Let us consider an assignment. It is essentially a list of problems. So, modeling an assignment breaks down to modeling a problem. A problem could have the following attributes:</p> Attribute Type id string question string type string options list answers tuple marks float <p>For grading, we only need two attributes, the problem-id and the answers. With this, the assignment model will look like the following. The entire assignment will now be a list of dictionaries:</p> <pre><code># assume that the assignment has three problems\n# the assignment will be a list of dictionaries\nassignment = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\n</code></pre> <p>A point to note. A singleton tuple is represented as <code>(&lt;item&gt;, )</code>. The comma cannot be ignored. Coming back to the assignment model, we see that there are several attributes in the table that haven't entered into the assignment dictionary since they are not relevant from the point of view of grading. They have been mentioned so that it gives a better understanding of how assignments can be modeled.</p>"},{"location":"chapter-6/lesson-6.4/#submission-model","title":"Submission Model","text":"<p>The submission model is slightly more involved. There are some global attributes like name of the user, the user's roll number and the time of submission. And then there are local attributes like the options selected for each problem.</p> Attribute Type name string roll_number string timestamp string problems list <p>Let us look at a sample submission:</p> <pre><code>submission = {\n                'name': 'Kapil Dev',\n                'roll_number': 'BSC1001',\n                'time': 'Sunday 18 April 2021 10:23:30 PM IST',\n                'problems': [\n                                {'id': '10001', 'selected': (0, 1)},\n                                {'id': '10002', 'selected': (1, )},\n                                {'id': '10003', 'selected': (3, )}                    \n                            ]\n              }\n</code></pre> <p><code>submission</code> is a fairly complicated object. To begin with, it is a dictionary. The first three keys do not pose any challenges. The value of the key <code>'problems'</code> is a list of dictionaries! We could add one more level of complexity. Since a user could make multiple submissions, we could have a list of submissions! But for now, let us not complicate things any further.</p>"},{"location":"chapter-6/lesson-6.4/#grader","title":"Grader","text":"<p>The assignment is a list of dictionaries. While this is not a bad representation, the grader has to search for the problem id through this list every time it has to grade a problem. Since the problem id is unique, we can  come up with a better representation for the assignment:</p> <pre><code>assignment_ = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\nassignment = dict()\nfor problem in assignment_:\n    problem_id = problem['id']\n    answers = problem['answers']\n    marks = problem['marks']\n    assignment[problem_id] = {'answers': answers, 'marks': marks}\n</code></pre> <p>The assignment now looks like this:</p> <pre><code>assignment = {\n                '10001': {\n                            'answers': (0, 1),\n                            'marks': 2.0\n                         },\n                '10002': {\n                            'answers': (1, ),\n                            'marks': 1.0\n                         },\n                '10003': {\n                            'answers': (2, ),\n                            'marks': 2.0\n                         },    \n             }\n</code></pre> <p>We are now ready to complete the grader using this new assignment model:</p> <pre><code>def grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    for problem in submission['problems']:\n        problem_id = problem['id']\n        selected = problem['selected']\n        answers = assignment[problem_id]['answers']\n        if answers == selected:\n            result += assignment[problem_id]['marks']\n    return result\n</code></pre>"},{"location":"chapter-6/lesson-6.5/","title":"Lesson-6.5","text":""},{"location":"chapter-6/lesson-6.5/#lesson-65","title":"Lesson-6.5","text":""},{"location":"chapter-6/lesson-6.5/#sets","title":"Sets","text":""},{"location":"chapter-6/lesson-6.5/#introduction","title":"Introduction","text":"<p>A set is an unordered collection with no duplicate elements [refer]. Unlike lists and tuples, there is no notion of order in a set. This is why it is called an unordered collection as opposed to a sequence. A set can be defined as follows:</p> <pre><code>even_nums = {2, 4, 6, 8, 10}\nprint(type(even_nums))\nprint(isinstance(even_nums, set))\n</code></pre>"},{"location":"chapter-6/lesson-6.5/#output","title":"Output","text":"<pre><code>&lt;class 'set'&gt;\nTrue\n</code></pre> <p>Notice the similarity in syntax between sets and dictionaries. Both are enclosed within curly braces. While a dictionary has key-value pairs in it, a set just has a collection of values. A set in Python is a remarkably accurate representation of a mathematical set. Therefore, most of the properties that you are used to seeing in mathematical sets nicely carry over to Python sets. This connection is so strong that you can often forget that you are dealing with Python sets.</p> <pre><code>nums_1 = {2, 4, 6, 8, 10}\nnums_2 = {2, 2, 4, 4, 6, 6, 8, 8, 10, 10}\nprint(nums_1, nums_2)\nprint(nums_1 == nums_2)\nprint(nums_1 is not nums_2)\n</code></pre>"},{"location":"chapter-6/lesson-6.5/#output_1","title":"Output","text":"<pre><code>{2, 4, 6, 8, 10} {2, 4, 6, 8, 10}\nTrue\nTrue\n</code></pre> <p>As stated before, sets do not support duplicate elements. We see that <code>nums_1</code> and <code>nums_2</code> are equal sets. However, they don't point to the same object. Sets support membership just like lists, tuples and dictionaries.</p> <pre><code>nums = {1, 2, 3, 4, 5}\nprint(1 in nums)\nprint(6 not in nums)\n</code></pre> <p>The number of elements in a set, which is the same as its cardinality, is given by the <code>len()</code> function:</p> <pre><code>nums = {1, 2, 3, 4, 5}\nprint(f'Cardinality of nums is {len(nums)}')\n</code></pre> <p>Sets cannot be indexed. This is quite reasonable as they are not ordered collections. The following code will throw an error:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nsome_set = {'this', 'is', 'a', 'set'}\nprint(some_set[0])\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>Any hashable object can be added to sets. This means most of the immutable types such as <code>int</code>, <code>float</code>, <code>str</code> and <code>tuple</code> can be added to sets. A small caveat as far as tuples are concerned: a tuple of lists is unhashable and therefore cannot be added to sets.</p> <pre><code>a_set = {1.0, 'one', 1, True, (1, )}    # valid set\nnot_a_set = {([1, 2], [3, 4])}          # not a valid set\n</code></pre> <p><code>not_a_set</code> returns a <code>TypeError</code> as expected.</p>"},{"location":"chapter-6/lesson-6.5/#iterating-through-sets","title":"Iterating through Sets","text":"<p>Though a set is not a sequence, iterating through the elements of a set is supported.</p> <pre><code>nums = {1, 2, 3, 4, 5}\nfor num in nums:\n    print(num)\n</code></pre>"},{"location":"chapter-6/lesson-6.5/#growing-sets","title":"Growing Sets","text":"<p>How do we define an empty set?</p> <pre><code>##### Alarm! Be careful about the variable name! #####\nempty_set = { }\nprint(isinstance(empty_set, set))\nprint(isinstance(empty_set, dict))\n##### Alarm! Be careful about the variable name! #####\n</code></pre> <p>We see that <code>empty_set</code> is in fact an empty dictionary. Computers are precise machines, which makes them very faithful. Few lessons back we used <code>{ }</code> to initialize an empty dictionary. It hasn't changed. <code>{ }</code> is still an empty dictionary. So, how do we define an empty set then?</p> <pre><code>empty_set = set()\nprint(isinstance(empty_set, set))\n</code></pre> <p>Simple enough! With the empty set and set-iteration defined, we can now grow sets from scratch.</p> <p>Consider the first 100 powers of 7:  $$ 7^1, 7^2, \\cdots, 7^{100} $$ Note down the last digit of each of these powers. How many of them are unique? What are these numbers?</p> <p>This problem has a simple mathematical solution. But humor me and assume that you don't know how to solve this problem. Let us go for a computational solution.</p> <pre><code>num = 1\ndigits = set()\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    digits.add(last)\nprint(digits)\n</code></pre> <p><code>add</code> is a method used to add elements to a set. The solution to this problem is a typical use case of sets. When you expect duplicate elements to come up often and if you are not concerned with duplicates, then sets are ideal objects for storage. The same problem can be solved using lists:</p> <pre><code>num = 1\ndigits = [ ]\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    if last not in digits:\n        digits.append(last)\nprint(digits)\n</code></pre>"},{"location":"chapter-6/lesson-6.5/#set-operations","title":"Set Operations","text":"<p>Mathematical sets are friendly objects. They routinely interact with each other through one of the following operations:</p> <ul> <li>Subset</li> <li>Superset</li> <li>Union</li> <li>Intersection</li> <li>Difference</li> </ul> <p>Python sets strive to be as friendly as their mathematical counterparts. We will see how each of these operations are represented:</p> <ul> <li>Subset: \\(A\\) is a subset of \\(B\\) if every element of \\(A\\) is present in \\(B\\). It is denoted by \\(A \\subseteq B\\). This is a binary relationship and its outcome can be determined in one of the two ways:</li> </ul> <pre><code>A = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nprint(A.issubset(B))    # method-1\nprint(A &lt;= B)           # method-2\n</code></pre> <p>Both lines return the value <code>True</code>.  A set \\(A\\) is a proper subset of \\(B\\) if every element in \\(A\\) is present in \\(B\\) and \\(A \\neq B\\). It is denoted by \\(A \\subset B\\). That is, there is at least one element in \\(B\\) which is not in \\(A\\):</p> <pre><code>A = {1, 2, 3}\nB = {1, 2, 3}\nprint(A &lt;= B)   # method-1\nprint(A &lt; B)    # method-2\n</code></pre> <p>The <code>A &lt; B</code> operator checks if <code>A</code> is a proper subset of <code>B</code>. In this case <code>A</code> is not a proper subset of <code>B</code>, so the second print statement returns <code>False</code>.</p> <ul> <li>Superset: \\(A\\) is a superset of \\(B\\) if every element of \\(B\\) is present in \\(A\\). It is denoted by \\(A \\supset B\\):</li> </ul> <pre><code>A = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nB.issuperset(A)     # method-1\nprint(B &gt;= A)       # method-2\n</code></pre> <ul> <li>Union: The union of two sets \\(A\\) and \\(B\\) is the set of elements that are present in either \\(A\\) or \\(B\\) or both. It is denoted by \\(A \\cup B\\).</li> </ul> <pre><code>A = {1, 3, 5}\nB = {2, 4, 6}\nC1 = A.union(B)     # method-1\nC2 = A | B          # method-2\nprint(C1, C2)\nprint(C1 == C2)\n</code></pre> <p>When there are multiple sets, we could do the following:</p> <pre><code>A1, A2, A3, A4 = {1}, {2, 3}, {4, 5, 6}, {7, 8, 9, 10}\nB1 = A1.union(A2, A3, A4)   # method-1\nB2 = A1 | A2 | A3 | A4      # method-2\nprint(B1, B2)\nprint(B1 == B2)\n</code></pre> <ul> <li>Intersection: The intersection of two sets \\(A\\) and \\(B\\) is the set of elements common to both. It is denoted by \\(A \\cap B\\).</li> </ul> <pre><code>A = {2, 4, 6}\nB = {2, 4}\nC1 = A.intersection(B)  # method-1\nC2 = A &amp; B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\n</code></pre> <p>What happens if there are no elements in common? We should get the empty set:</p> <pre><code>even, odd = {2, 4, 6}, {1, 3, 5}\ncommon = even &amp; odd\nassert common == set()\n</code></pre> <p>We have used an assert statement just to introduce some variation. As it doesn't raise an <code>AssertionError</code>, we are right on target.</p> <ul> <li>Difference: The difference between two sets \\(A\\) and \\(B\\) is the set of elements present in one set but not in the other. It is denoted by \\(A - B\\) or \\(B - A\\), and the two are not the same! </li> <li>\\(A - B\\) is the set of elements in \\(A\\) which are not in \\(B\\).</li> <li>\\(B - A\\) is the set of elements in \\(B\\) which are not in \\(A\\).</li> </ul> <pre><code>A = {1, 2, 3, 4}\nB = {2, 4, 5}\nC1 = A.difference(B)    # method-1\nC2 = A - B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\nD1 = B.difference(A)    # method-1\nD2 = B - A              # method-2\nprint(D1, D2)\nprint(D1 == D2)\n</code></pre>"},{"location":"chapter-6/lesson-6.5/#other-set-methods","title":"Other Set Methods","text":"<p>The methods that we saw in the previous section had a mathematical flavor. Now, we shall look at those methods that have a computational flavor!</p> <p>To remove an element from the set, we can use the <code>remove</code> method:</p> <pre><code>A = {'this', 'is', 'a', 'set'}\nprint('Before', A)\nA.remove('this')\nprint('After', A)\n</code></pre> <p>If we try to remove an element that is not present in the set, the interpreter will throw a <code>KeyError</code>:</p> <pre><code>A = {'this', 'is', 'a', 'set'}\nA.remove('cool')    # error!\n</code></pre> <p>Consider the following problem:</p> <p>Given a list <code>L</code>, extract all unique elements from it and store the result in another list, <code>L_uniq</code>. The order of elements does not matter.</p> <p>Let us first look at a solution that doesn't use sets:</p> <pre><code>L = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nL_uniq = [ ]\nfor elem in L:\n    if elem not in L_uniq:\n        L_uniq.append(elem)\nprint(L_uniq)\n</code></pre> <p>Now, for some set magic:</p> <pre><code>L = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nS = set(L)\nL_uniq = list(S)\nprint(L_uniq)\n</code></pre> <p>Passing a list to the <code>set</code> function removes all duplicates and returns the unique elements.</p>"},{"location":"chapter-6/lesson-6.5/#mutability","title":"Mutability","text":"<p>Sets are mutable entities. </p> <pre><code>A = {1, 2, 3}\nB = A\nB.add(4)\nprint(A, B)\nprint(A is B)\n</code></pre> <p><code>A</code> and <code>B</code> are the same objects. As before, there are two ways to do a shallow copy:</p> <pre><code>A = {1, 2, 3}\nB1 = A.copy()\nB2 = set(A)\nB1.add(4)\nB2.add(0)\nprint(A, B1, B2)\nprint(A is not B1)\nprint(A is not B2)\n</code></pre>"},{"location":"chapter-7/lesson-7.1/","title":"Lesson 7.1","text":""},{"location":"chapter-7/lesson-7.1/#lesson-71","title":"Lesson 7.1","text":""},{"location":"chapter-7/lesson-7.1/#file-handling","title":"File Handling","text":""},{"location":"chapter-7/lesson-7.1/#why-files","title":"Why files","text":"<p>The best way to motivate files is to take the human example. Consider our memory. There is a certain volume of information that we can retain in our working memory. A popular claim is that we can retain around seven chunks of information in our short-term memory. Anything that exceeds this volume of information, we have to resort to external aids such as notebooks.</p> <p>Something similar happens in computers. Modern day computers are quite powerful and can retain several chunks of information at a time. Though computers are machines, the amount of short-term memory that they possess is still finite. This is where the idea of external storage comes in. Files are to computers what books are to humans. A file is used to record information in a permanent location so that it can be retrieved as and when needed.</p>"},{"location":"chapter-7/lesson-7.1/#file-handling_1","title":"File handling","text":"<p>We are all used to opening files in our computers by simply double clicking on an icon. Let us take the example of a simple file having the following contents:</p> <pre><code>Income      Expenditure\n12,000      10,000\n50,000      45,000\n75,000      35,000\n14,000      12,000\n60,000      40,000\n</code></pre> <p>This file has the income-expenditure details of a family for five months. We wish to create a new file that has the savings details added as a third column. That is, we wish to generate the following file:</p> <pre><code>Income      Expenditure     Savings\n12,000      10,000          2,000\n50,000      45,000          5,000\n75,000      35,000          40,000\n14,000      12,000          2,000\n60,000      40,000          20,000\n</code></pre> <p>This seems like a simple task. Open this file, plug the numbers in the calculator, get the result and paste it in a new column and we are done. But what if the number of entries in the file increases? For example, let us say we wish to perform this operation for all families in the neighborhood. If we have 10 years worth data for 1000 families, we are looking at \\(1000 * 10 * 12 = 120,000\\) entries! Our calculator will break down and so will we out of exhaustion.</p> <p>This is where Python comes to our rescue. We can write a piece of code to automate the whole process. And all it is going to take is a few lines of code! In the next few lessons, we will see how to process files. We will learn the following operations:</p> <ul> <li>opening a file and closing it</li> <li>reading from a file</li> <li>writing to a file</li> </ul> <p>File handling is an umbrella term that denotes all these operations.</p>"},{"location":"chapter-7/lesson-7.2/","title":"Lesson-7.2","text":""},{"location":"chapter-7/lesson-7.2/#lesson-72","title":"Lesson-7.2","text":""},{"location":"chapter-7/lesson-7.2/#file-handling","title":"File Handling","text":""},{"location":"chapter-7/lesson-7.2/#creating-a-file-in-replit","title":"Creating a file in Replit","text":"<p>Let us use <code>Replit</code> and use the <code>Add File</code> button to create a file.</p> <p></p> <p>Each file should be given a name. Let us call our file <code>examples.txt</code>. Now, we shall add the following lines to the file:</p> <pre><code>one\ntwo\nthree\nfour\nfive\n</code></pre> <p>After creating the file, this is how it should look in Replit when we click on <code>examples.txt</code>:</p> <p></p> <p><code>examples.txt</code> is called a text file. We can identify this from the extension \u2014 <code>txt</code> that comes at the end of files. Don't worry too much about the extension. It is enough if you know that different files come with different extensions. In fact, <code>main.py</code> is itself a file with <code>py</code> as the extension. This is why it gets listed along with <code>examples.txt</code> under the <code>Files</code> tab in Replit.</p>"},{"location":"chapter-7/lesson-7.2/#opening-and-reading-from-a-file","title":"Opening and reading from a file","text":"<p>Now, it is time to open the file and print the contents on to the console. For this, we head to <code>main.py</code> and type the following lines.</p> <pre><code>f = open('examples.txt', 'r')\nfor line in f:\n    print(line)\nf.close()\n</code></pre> <p><code>open()</code> is a built-in function in Python that accepts two arguments:</p> <ul> <li>file name</li> <li>mode</li> </ul> <p>The first argument is the file name, which is <code>'examples.txt'</code> in our case. The second argument corresponds to the mode in which we want to process the file. In this case, we want to read the file. So, we open the file in read-mode. The single character <code>'r'</code> is used to denote this mode. Notice that both the arguments passed to <code>open()</code> are strings.</p> <p>The <code>open()</code> function returns a file object. Do no worry about the terminology for now. We will discuss it in detail in the next lesson. For now, it is enough to know that the <code>open()</code> function returns a file object that we have called <code>f</code> in our code.</p> <p>In lines 2-3, we loop through each line in the file and print it. As simple as that. Finally, in line 4, we close the file using the method <code>close()</code>. It is a good practice to close the file once we are done with processing it. Let us now see the output at the end of execution of this code block:</p> <pre><code>one\n\ntwo\n\nthree\n\nfour\n\nfive\n</code></pre> <p>Now that doesn't seem right. We have all the contents of the file, but for whatever reason, there is an extra line between successive lines in the file. To suppress these new lines, we have to modify our print function slightly:</p> <pre><code>f = open('examples.txt', 'r')\nfor line in f:\n    print(line, end = '')   # there is NO SPACE between the quotes\nf.close()\n</code></pre> <p>Note the change in line 3. By default, <code>print()</code> appends a newline character (<code>'\\n'</code>) at the end of whatever it is printing. By using <code>end = ''</code>, we are just appending the empty string. Therefore, the extra line that was appearing in the output will no longer bother us when we execute the code we have just written:</p> <pre><code>one\ntwo\nthree\nfour\nfive\n</code></pre>"},{"location":"chapter-7/lesson-7.2/#opening-and-writing-to-a-file","title":"Opening and writing to a file","text":"<p>Consider the following code-block:</p> <pre><code>f = open('writing.txt', 'w')\nf.write('one ')\nf.write('two ')\nf.write('three ')\nf.write('four ')\nf.write('five')\nf.close()\n</code></pre> <p>Here, we have opened the file in write mode. When this code is executed, it creates a file in Replit called <code>writing.txt</code>.</p> <p></p> <p>We have used what is called the <code>write()</code> method to write to the file. We pass the content we wish to write as a string argument to the method. Notice that, even though we have used the <code>write()</code> method to write five different words on five lines in the code, all of them get written to the same line in the file. The way to tell the file object to go to a new line is using the <code>'\\n'</code> character. Let us now, try the following piece of code:</p> <pre><code>f = open('writing.txt', 'w')\nf.write('one')\nf.write('\\n')\nf.write('two')\nf.write('\\n')\nf.write('three')\nf.write('\\n')\nf.write('four')\nf.write('\\n')\nf.write('five')\nf.close()\n</code></pre> <p></p> <p>A better way of achieving this in fewer lines of code is to append the <code>\\n</code> character to every line of the file we wish to write:</p> <pre><code>f = open('writing.txt', 'w')\nf.write('one\\n')\nf.write('two\\n')\nf.write('three\\n')\nf.write('four\\n')\nf.write('five')\nf.close()\n</code></pre> <p>This results in the same file but with fewer lines of code! In the next lesson, we will take a closer look at the idea of a file object.</p> <p> </p> <p>Notice that we didn't add a <code>'\\n'</code> after <code>five</code>. Why do you think that is the case? Try running the code with <code>'\\n'</code> after <code>five</code>.</p>"},{"location":"chapter-7/lesson-7.3/","title":"Lesson 7.3","text":""},{"location":"chapter-7/lesson-7.3/#lesson-73","title":"Lesson 7.3","text":""},{"location":"chapter-7/lesson-7.3/#file-object","title":"File Object","text":"<p>As mentioned earlier, the <code>open()</code> function returns a file object. The following image gives a better picture of the whole setup.</p> <p></p> <p>What is a file object? Let us use the following analogy: </p> <p>You are the CEO of a tech company. Even though you are good at multi-tasking, there are simply too many things for you to keep track of. To help you manage the mounting load of activities, you hire a personal assistant (PA). Think about the kind of work you generally assign to a PA. Let us say that you are meeting delegates from another company at 5:00 PM next Tuesday. The typical instruction to your PA would be this: \"make a note of this meeting\". Your PA would dutifully record this information in a file.</p> <p>Few days later, you might be suddenly reminded of this important meeting. At this point, this would be your instruction: \"fetch me the details of the meeting with those delegates\". In both cases, notice that it is your PA who is interacting with a file. In the first instruction, your PA noted down the details of a meeting in a file. In the second instruction, your PA retrieved the information from the file.</p> <p>The file object is your PA who mediates between you, the coder, and the file that resides on the hard disk of your computer. You pass an instruction to your file object, which does the job of reading and writing to a file. All communication between you and the file is routed through the file object.</p>"},{"location":"chapter-7/lesson-7.3/#mode","title":"Mode","text":"<p>In the following sections, we will briefly discuss about the two modes that a file can be opened in. We will go in depth in later lessons.</p>"},{"location":"chapter-7/lesson-7.3/#read-mode","title":"Read mode","text":"<p>The dotted line in the image given below corresponds to the mode in which you wish to process the file. This instruction always originates from you and is directed at the file object. When you are reading from a file, information flows from the file, through the file object and reaches you. This represented by the solid arrow. </p> <p></p> <p>To read a file, we open it in the read mode:</p> <pre><code>f = open('&lt;file_name&gt;', 'r')\n# ...\n# code for reading something from file\n# ...\nf.close()\n</code></pre>"},{"location":"chapter-7/lesson-7.3/#write-mode","title":"Write mode","text":"<p>When you are writing to a file, information flows from you, through the file object and to the file.</p> <p></p> <p>To write to a file, we open it in the write mode:</p> <pre><code>f = open('&lt;file_name&gt;', 'w')\n# ...\n# code for writing something into the file\n# ...\nf.close()\n</code></pre> <p>In the next lesson, we will see some more aspects of file handling.</p>"},{"location":"chapter-7/lesson-7.4/","title":"Lesson 7.4","text":""},{"location":"chapter-7/lesson-7.4/#lesson-74","title":"Lesson 7.4","text":""},{"location":"chapter-7/lesson-7.4/#file-methods","title":"File methods","text":""},{"location":"chapter-7/lesson-7.4/#read","title":"<code>read()</code>","text":"<p>Let us continue working with <code>examples.txt</code> that we created in the previous lesson. If you recall, <code>examples.txt</code> has the following contents:</p> <pre><code>one\ntwo\nthree\nfour\nfive\n</code></pre> <p>Let us now look at a different way of reading from a file, using the <code>read()</code> method.</p> <pre><code>f = open('examples.txt', 'r')\ncontent = f.read()\nprint(content)\nf.close()\n</code></pre> <p>This gives the following output:</p> <pre><code>one\ntwo\nthree\nfour\nfive\n</code></pre> <p><code>read()</code> is a method defined for the file object. When it is called without any argument, it returns a string that contains the entire content of the file. If you head to the console (it is to the right of the editor in Replit) and type the string <code>content</code>, this is what you get:</p> <pre><code>'one\\ntwo\\nthree\\nfour\\nfive'\n</code></pre> <p>Notice that <code>content</code> is a single string. It contains the contents of the file, but between consecutive lines in the file, there is a <code>'\\n'</code>:</p> <p></p> <p>Except for the last line, every line in the file ends with a <code>'\\n'</code> character. When this string is printed to the console \u2014 <code>print(content)</code> \u2014 we get five separate lines even though we are only passing a single string to the <code>print()</code> function. This is because of the presence of the newline character in the string. Whenever a newline character is encountered, the Python interpreter moves to the next line.</p> <p>Now, it is clear why the following piece of code printed an extra line between consecutive lines in the file:</p> <pre><code>f = open('examples.txt', 'r')\nfor line in f:\n    print(line)     \n    # line ends with a \\n character for all lines except the last one\n    # this is why we get an empty line between consecutive lines in the console\nf.close()\n</code></pre>"},{"location":"chapter-7/lesson-7.4/#readline","title":"<code>readline()</code>","text":"<p>As its name suggests, the <code>readline()</code> method reads from the file one line at a time:</p> <pre><code>f = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nf.close()\n</code></pre> <p>The variables <code>line1</code>, <code>line2</code>, \u2026, <code>line5</code> will hold the following values at the end of execution of the code given above:</p> Variable Value <code>line1</code> <code>'one\\n'</code> <code>line2</code> <code>'two\\n'</code> <code>line3</code> <code>'three\\n'</code> <code>line4</code> <code>'four\\n'</code> <code>line5</code> <code>'five'</code> <p>Notice that <code>line5</code> doesn't have a <code>'\\n'</code> at the end as it is the last line in the file. Here, we know that there are five lines in the file. This helped us define five separate variables. But what if there are more lines? Generally, we read a file so as to see what its contents are because we don't know what is there in it. Clearly, we need a way to figure out when the file ends.</p> <p>Now, consider the following code. What happens if we try to read the file using <code>readline()</code> after all the lines in the file have been read?</p> <pre><code>f = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nline = f.readline()\nf.close()\n</code></pre> <p>If we execute this and head to the console, we see that the variable <code>line</code> defined in line 7 is an empty string! This gives us a way to determine when a file is empty:</p> <p> </p> <p>Keep reading lines from the file until an empty string is encountered.</p> <p>Let us implement this:</p> <pre><code>f = open('examples.txt', 'r')\nline = f.readline()\nwhile line != '':\n    print(line, end = '')\n    line = f.readline()\nf.close()\n</code></pre> <p>Here, we have managed to read the file using just one string variable. Let us make few more changes to this code:</p> <pre><code>f = open('examples.txt', 'r')\nline = f.readline()\nwhile line:\n    print(line.strip())\n    line = f.readline()\nf.close()\n</code></pre> <p>In this code, we have made two changes. One in line 3 and another in line 4. The loop condition in line-3  checks for the empty string. If <code>line</code> is an empty string, it evaluates to <code>False</code> and the loop will be terminated. This is a compact way of writing <code>line != ''</code>. Python treats empty sequences as <code>False</code>. If this is confusing, execute the following code and check the output:</p> <pre><code>line = ''\nif not line:\n    print('It works!')  \n</code></pre> <p>In line 4, we are using the <code>strip()</code> method to strip the string <code>line</code> of all the whitespace characters at the beginning and at the end. In this way, the trailing newline at the end of <code>line</code> will be stripped. This way, we don't need to use the <code>end</code> argument.</p>"},{"location":"chapter-7/lesson-7.4/#readlines","title":"<code>readlines()</code>","text":"<p>Finally, Python also provides a way to read the file and store it as a list of lines:</p> <pre><code>f = open('examples.txt', 'r')\nlines = f.readlines()\nfor line in lines:\n    print(line.strip())\nf.close()\n</code></pre> <p>Here, <code>lines</code> is a list of lines. Notice that each element in <code>lines</code> corresponds to one line in the file. It is always a string:</p> <pre><code>['one\\n', 'two\\n', 'three\\n', 'four\\n', 'five']\n</code></pre>"},{"location":"chapter-7/lesson-7.4/#write","title":"<code>write()</code>","text":"<p>We already saw the <code>write()</code> method earlier. There, we used the <code>write()</code> method five times to write five lines. Let us now use a loop with the help of the <code>lines</code> list. First, we run the code:</p> <pre><code>f = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor line in lines:\n    f.write(line + '\\n')\nf.close()\n</code></pre> <p>When we execute this, the following file is created:</p> <p></p> <p>We see that there are six lines in the file and not five, though we seem to have written only five lines. The problem is with line-4, where we are adding <code>'\\n'</code> after every string in the list <code>lines</code>. We should make sure that we don't add a <code>'\\n'</code> after the last string in the list:</p> <pre><code>f = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor i in range(len(lines)):\n    line = lines[i]\n    if i != len(lines) - 1:\n        f.write(line + '\\n')\n    else:\n        f.write(line)\nf.close()\n</code></pre> <p>Now, check the file, you will see that it has exactly five lines! Let us now try to write an integer to the file:</p> <pre><code>f = open('writing.txt', 'w')\nf.write(1)\nf.close()\n</code></pre> <p>This throws the following error:</p> <pre><code>Traceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    f.write(1)\nTypeError: write() argument must be str, not int\n</code></pre> <p>We see that <code>write()</code> method accepts only string arguments. If we want to write integers to a file, we have to first convert them to strings:</p> <pre><code>f = open('writing.txt', 'w')\nf.write(str(1))\nf.close()\n</code></pre> <p> </p> <p>As an exercise, try to run the following code. What do you observe? Why do you think this happens?</p> <pre><code>f = open('writing.txt', 'w')\nf.writeline(str(1))\nf.close()\n</code></pre>"},{"location":"chapter-7/lesson-7.4/#writelines","title":"<code>writelines()</code>","text":"<p>We can write a list of lines to a file using the <code>writelines()</code> method:</p> <pre><code>f = open('writing.txt', 'w')\nlines = ['1\\n', '2\\n', '3\\n', '4\\n', '5']\nf.writelines(lines)\nf.close()\n</code></pre> <p>Note that the argument passed to the <code>writelines()</code> method is a list of strings. This will create a file having the following contents:</p> <pre><code>1\n2\n3\n4\n5\n</code></pre>"},{"location":"chapter-7/lesson-7.5/","title":"Lesson 7.5","text":""},{"location":"chapter-7/lesson-7.5/#lesson-75","title":"Lesson 7.5","text":""},{"location":"chapter-7/lesson-7.5/#reading-csv-files","title":"Reading CSV files","text":""},{"location":"chapter-7/lesson-7.5/#csv-files","title":"CSV files","text":"<p>Now that we are familiar with reading and writing simple files, let us see how to handle slightly more complex files. CSV files<sup>1</sup> are quite common in data science.In a CSV file, adjacent values in each line are separated by commas. A CSV file looks like this:</p> <pre><code>col0,col1,col2,col3\nrow1,item11,item12,item13\nrow2,item21,item22,item23\nrow3,item31,item32,item33\nrow4,item41,item42,item43\nrow5,item51,item52,item53\n</code></pre> <p>Such files are a good choice for representing tabular data. For the rest of this lesson, we will assume that CSV files are used to represent some such tabular data. The first line in the file is called the header. The header gives information about the fields or columns in the data. The rest of the lines can be treated as rows in the data. If this file is represented as a table, it would look like this:</p> col0 col1 col2 col3 row1 item11 item12 item13 row2 item21 item22 item23 row3 item31 item32 item33 row4 item41 item42 item43 row5 item51 item52 item53"},{"location":"chapter-7/lesson-7.5/#reading-a-csv-file","title":"Reading a CSV file","text":"<p>Let us create a CSV file in Replit and name it <code>table.csv</code>:</p> <p></p> <p>Opening and reading a CSV file is no different from opening a text file. Let us try to print the lines in the file:</p> <pre><code>f = open('table.csv', 'r')\nfor line in f:\n    print(line.strip())\nf.close()\n</code></pre> <p>This is the output we get:</p> <pre><code>Name,Physics,Mathematics,Chemistry\nNewton,100,98,90\nEinstein,100,85,88\nRamanujan,70,100,70\nGauss,100,100,70\n</code></pre> <p>So far so good. Now that we are able to extract the lines from the file, let us start asking some questions. </p> <p> </p> <p>Print the chemistry marks scored by the students, one in each line.</p> <p>This requires us to extract the last column from the file. How do we do this? Consider any one line in the file, say the second one:</p> <pre><code># The `\\n` at the end will be present for all lines except the last one\nline = 'Newton,100,98,90\\n'     \nline = line.strip() # removes the \\n character\n</code></pre> <p>This is a string that corresponds to one row in the file. If we need to separate it into different columns, we need to use the <code>split()</code> method and split the line based on a comma:</p> <pre><code>line = 'Newton,100,98,90\\n'\nline = line.strip()\ncolumns = line.split(',')\nprint(columns)\n</code></pre> <p>This returns a list of strings:</p> <pre><code>['Newton', '100', '98', '90']\n</code></pre> <p>To extract the last column, we just need to take the last element from this list and convert it into an integer:</p> <pre><code>line = 'Newton,100,98,90'\nline = line.strip()\ncolumns = line.split(',')\nchem_marks = int(columns[-1])\nprint(chem_marks)\n</code></pre> <p>That is all! We have done this for one row. We need to do this for all the rows. Enter loop:</p> <pre><code>f = open('table.csv', 'r')\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\n</code></pre> <p>Aha, but we get an error:</p> <pre><code>Traceback (most recent call last):\n  File \"main.py\", line 5, in &lt;module&gt;\n    chem_marks = int(columns[-1])\nValueError: invalid literal for int() with base 10: 'Chemistry'\n</code></pre> <p>Can you see why? We have tried to convert the last column of the header into an integer as well. The moral of the story is that when we are reading CSV files, we need to find a way to deal with the header. Let us modify our code towards that end:</p> <pre><code>f = open('table.csv', 'r')\nheader = f.readline()       \n# The file object has finished reading the first line\n# It is now ready to read from the second line onwards\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\n</code></pre> <p>This works! In the second line, we read the header. Now, when the for loop starts in line 5, we are ready to read from the second line in the file. Consider the following approach that uses the <code>readlines()</code> method alone:</p> <pre><code>f = open('table.csv', 'r')\nlines = f.readlines()\n# lines[1: ] is the rest of the list \n# after ignoring the header\nfor line in lines[1: ]:         \n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)               \nf.close()\n</code></pre> <p><code>readlines()</code> is a reasonable choice for reading small files, say under 1000 lines. We get all the lines of the files in a list. Reading a file reduces to processing a list of strings. If <code>lines</code> is the list of lines, then <code>lines[i]</code> corresponds to the \\((i + 1)^{th}\\) line in the file. Going the other way, the \\(i^{th}\\) line in the file corresponds to the string <code>lines[i - 1]</code>.</p> <p>Processing large files</p> <p>When it comes to large files, <code>readline()</code> is the best method to use. Processing large files is best done by reading one line at a time. Using <code>readlines()</code> for large files is a dangerous idea. This is because, <code>readlines()</code> dumps the entire content of the file into a list of strings. When the file is large, this list will occupy a large amount of memory. Let us try to write the same program given above using the <code>readline</code> method:</p> <pre><code>f = open('table.csv', 'r')\nheader = f.readline().strip()       # this is for the header\nline = f.readline()                 # second line; actual rows begin\nwhile line:\n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)\n    line = f.readline()             # read the next line in the file\nf.close()\n</code></pre>"},{"location":"chapter-7/lesson-7.5/#files-to-collections","title":"Files to Collections","text":"<p>It is often useful to convert a CSV file and store in a suitable collection. We could do this in several ways. Here, let us try to create the following list of dictionaries from the file:</p> <pre><code>data = [\n{'Name': 'Newton', 'Physics': 100, 'Mathematics': 98, 'Chemistry': 90}, \n{'Name': 'Einstein', 'Physics': 100, 'Mathematics': 85, 'Chemistry': 88}, \n{'Name': 'Ramanujan', 'Physics': 70, 'Mathematics': 100, 'Chemistry': 70}, \n{'Name': 'Gauss', 'Physics': 100, 'Mathematics': 100, 'Chemistry': 70}]\n</code></pre> <p>Couple of points to note. </p> <ul> <li>This is a list of dictionaries. Each dictionary in the list corresponds to one row in the file.</li> <li>The elements in the header appear as keys in every dictionary.</li> <li>The values of the dictionary are of different data types. Names are strings, marks are integers.</li> </ul> <p>This is going to be a fairly long code. Let us break it down. First, some basic processing to get the list of lines from the file after stripping them of the trailing newlines:</p> <pre><code>f = open('table.csv', 'r')\nlines = [ ]\nfor line in f.readlines():\n    line = line.strip()\n    lines.append(line)\n# Now, we have the list of lines\n</code></pre> <p>Next, let us get the details of the header:</p> <pre><code>header = lines[0].split(',')    # lines[0] is the first row\nnum_cols = len(header)\n# Now, we have the header information\n# We also know the number of columns in the file\n</code></pre> <p>Now, it is time to go through the remaining lines in the file:</p> <pre><code>### Block-3 ###\ndata = [ ]                      # list to store the contents\nfor line in lines[1: ]:         # ignore the header\n    cols = line.split(',')      # split the column based on comma\n    row_dict = dict()           # create a dict to store this particular row\n    for i in range(num_cols):   # go through each element (column) in this row\n        key = header[i]         # key will be this column's name\n        if key == 'Name':       # are we storing a name or a number?\n            value = cols[i]     # since this is a name, don't convert to int\n        else:   \n            value = int(cols[i])    # since this is marks, convert to int\n        row_dict[key] = value       # update dict\n    data.append(row_dict)           # append this row to the list data\nf.close()\n</code></pre> <ol> <li> <p>CSV stands for comma-seperated values. Learn more about this file type here \u21a9</p> </li> </ol>"},{"location":"chapter-8/lesson-8.1/","title":"Lesson 8.1","text":""},{"location":"chapter-8/lesson-8.1/#lesson-81","title":"Lesson 8.1","text":""},{"location":"chapter-8/lesson-8.1/#objects-and-classes","title":"Objects and Classes","text":"<p>Objects are at the core of object oriented programming. With minimum jargon, let us try to understand what it all means. The simplest way of understanding the idea of objects is with the help of this wonderful phrase:</p> <p>Unity in diversity</p> <p>What unites all of us? We are all humans. We call this planet home.</p> <p>And yet, each of us is different. Each individual is unique. For example, height and weight are two obvious properties that make each individual stand out. In more philosophical terms, there are two forces in operation here: a global force that unites all of us and a local force that gives each one of us our own special identity. In the terminology of object oriented programming, each human being is an object. But all these objects belong to the class called \"Humanity\".</p> <p>This idea can be extended further. As a more mundane example, think about cars on the road. No two cars are the same. The brand of a car is one obvious point of difference. Even two cars of the same brand could be moving at different speeds. The speed of a car is another point of difference. However, a car is not the same as a train. We know a car when we see one. There are certain global features that are common to all cars and there is no mistaking that. In the terminology of object oriented programming, each car is an object. But all these objects belong to the class called \"Car\".</p> <p>We are now ready to move from the concrete to the abstract.</p> <p>Objects are entities that have certain attributes along with operations associated with them. </p> <p>For example, cars on the road could have the following attributes: speed, fuel level. The operations associated with it could be: start, stop, accelerate, decelerate, fill fuel tank. Given this basic understanding of what we mean by objects, we are now ready to define a class:</p> <p>A class is a blueprint or a template that is used to create objects.</p> <p>The specification of what constitutes a car is present in a class, say <code>Car</code>, note that capital \"C\". The specification of what makes a human is present in another class, say <code>Human</code>. Think about a class as a Google form. A form is nothing but a template. The template is created once and then it is distributed. Each of us fills this form differently hence creating different objects.</p> <p>Object Oriented Programming (OOP) is a paradigm that looks at the world as a collection of objects and the interactions among them. </p> <p>Rather than focusing on more definitions, let us jump in and look at OOP in action.</p>"},{"location":"chapter-8/lesson-8.1/#oop-in-python-an-example","title":"OOP in Python: an example","text":"<p>Consider a very simple template for a student that has following information:</p> <ul> <li>Name</li> <li>Marks</li> </ul> <p>We want to perform the following operations:</p> <ul> <li>Update the marks of the student</li> <li>Print student details</li> </ul> <pre><code>class Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n\n    def update_marks(self, marks):\n        self.marks = marks\n\n    def print_details(self):\n        print(f'{self.name}')\n</code></pre> <p><code>class</code> is a keyword in Python to define classes. It is similar to the <code>def</code> keyword that is used to define functions. <code>Student</code> is the name of the class that we are creating. Within the class, we see that there are three functions: <code>__init__</code>, <code>update_marks</code> and <code>print_details</code>. Functions defined inside a class are given a special name, they are called methods of the class. Among the methods that can be defined for a class, <code>__init__</code> holds a special place and is called the constructor. Let us first see how to create an object of type <code>Student</code>:</p> <pre><code>anish = Student('Anish', 95)\n</code></pre> <p><code>anish</code> is now an object of type <code>Student</code>. To verify this, run the following command:</p> <pre><code>print(type(anish)) # output should be: &lt;class '__main__.Student'&gt;\n</code></pre> <p>We shall take up this example in the next lesson and understand various features of a class.</p>"},{"location":"chapter-8/lesson-8.2/","title":"Lesson 8.2","text":""},{"location":"chapter-8/lesson-8.2/#lesson-82","title":"Lesson 8.2","text":""},{"location":"chapter-8/lesson-8.2/#classes-and-objects","title":"Classes and Objects","text":"<p>Let us continue with the <code>Student</code> class. For now, don't bother too much about the variable <code>self</code>. We will get to that soon.</p> <pre><code>class Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n\n    def update_marks(self, marks):\n        self.marks = marks\n\n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\n</code></pre> <p>As we saw at the end of the previous lesson, an object of the class <code>Student</code> can be created like this:</p> <pre><code>anish = Student('Anish', 80)\n</code></pre> <p>Notice that we have used the name of the class in the RHS of the assignment statement. This invokes what is called the constructor \u2014 <code>__init__()</code> method \u2014 of the class. Since the constructor has two parameters (ignore <code>self</code> for now) <code>name</code> and <code>marks</code>, we have to pass them as arguments while creating the object.</p> <p>The two arguments are then assigned to <code>self.name</code> and <code>self.marks</code> respectively. These two variables are called the attributes of the object. Attributes can be accessed using the <code>.</code> operator:</p> <pre><code>print(anish.name)\nprint(anish.marks)\n</code></pre> <p><code>__init__()</code>, <code>update_marks()</code> and <code>print_details()</code> are called methods. A method is effectively just a function that is defined in a class. Methods can be accessed using an object. If we wish to update Anish's marks to \\(95\\), then we invoke the method using the object <code>anish</code>:</p> <pre><code>anish.update_marks(95)\n</code></pre> <p>When <code>anish.update_marks(95)</code> is called, the attribute <code>marks</code> that is tied to the object <code>anish</code> is updated to \\(95\\).</p> <p>To summarize, <code>anish</code> is an object of type <code>Student</code> having two attributes \u2014 <code>name</code> and <code>marks</code> \u2014 that can be accessed using the <code>.</code> operator. This object is also equipped with two methods (ignoring the constructor), one to update the marks and the other to print the details of the object. Attributes define the state of an object. Different objects of the same class could have different attributes. Naively speaking, methods help to update the values of the attributes. Therefore, the methods capture the behaviour of the object.</p>"},{"location":"chapter-8/lesson-8.2/#self","title":"<code>self</code>","text":"<p>Some of you might be wondering about the variable <code>self</code> that crops in so many places in the definition of the class. The variable <code>self</code> is used to point to the current object. To get a better understanding, let us create two different <code>Student</code> objects:</p> <pre><code>anish = Student('Anish', 90)\nlakshmi = Student('Lakshmi', 95)\n</code></pre> <p>How do we print the details of the student Lakshmi?</p> <pre><code>lakshmi.print_details()\n</code></pre> <p>When this method is called, Python actually ends up invoking the following function:</p> <pre><code>Student.print_details(lakshmi)\n</code></pre> <p>That is, it passes the current object as an argument. So, the variable <code>self</code> points to the current object. Another example:</p> <pre><code>anish.update_marks(95)\n</code></pre> <p>This is equivalent to the function call:</p> <pre><code>Student.update_marks(anish, 95)\n</code></pre> <p>This is a mechanism that Python uses to know the object that it is dealing with. And for this reason, the first parameter in every method defined in a class will be <code>self</code>, and it will point to the object calling the method i.e., the current object.</p> <p>This should also clear up any confusion that lines 3 and 4 could have caused:</p> <pre><code>class Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n</code></pre> <p><code>self.name = name</code> is the following operation: assign the value of the argument <code>name</code> to the current object's attribute <code>self.name</code>. A similar operation follows for <code>self.marks</code>.</p>"},{"location":"chapter-8/lesson-8.2/#class-attributes-vs-object-attributes","title":"Class Attributes vs Object Attributes","text":"<p>So far all attributes that we have seen are object attributes. Given an attribute, say <code>name</code> or <code>marks</code>, it is different for different objects. The <code>name</code> attribute of <code>anish</code> is different from the corresponding attribute fo the object <code>lakshmi</code>. Now, we shall see another kind of attribute.</p> <p>Let us say that we wish to keep track of the number students in our program. That is, when a new student joins our program, we need to update a counter. How do we do that? We need an attribute that is common to all objects and is not tied to any individual object. At the same time, we should be able to update this attribute whenever a new object is created. This is where the concept of class attributes comes in:</p> <pre><code>class Student:\n    counter = 0\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n        Student.counter += 1\n\n    def update_marks(self, marks):\n        self.marks = marks\n\n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\n</code></pre> <p>Now, let us say that three students join the program:</p> <pre><code>madhavan = Student('Madhavan', 90)\nprint('Number of students in the program =', Student.counter)\nandrew = Student('Andrew', 85)\nprint('Number of students in the program =', Student.counter)\nusha = Student('Usha', 95)\nprint('Number of students in the program =', Student.counter)\n</code></pre> <p>This gives the following output:</p> <pre><code>Number of students in the program = 1\nNumber of students in the program = 2\nNumber of students in the program = 3\n</code></pre> <p>Notice that we have used <code>Student.counter</code> to access the attribute <code>counter</code>. Such attributes are called class attributes. All objects of the class share this attribute. At this stage, we can try the following exercise. What do you think the output will be?</p> <pre><code>print(madhavan.counter)\n</code></pre> OUTPUT <pre><code>3\n</code></pre> <p>A class attribute can be accessed by any of the objects. But, now, try to run this code:</p> <pre><code>madhavan.counter = -1\nprint(\"Student counter:\", Student.counter)\nprint(\"Madhavan counter:\", madhavan.counter)\n</code></pre> OUTPUT <pre><code>Student counter: 3\nMadhavan counter: -1\n</code></pre> <p>This seems confusing! But a moment's thought will convince you that it is not so hard. In line 20, we are creating an object attribute with the same name as the class attribute! If the same attribute name occurs in both an object and a class, then Python prioritizes the object attribute. In other words, when we change <code>madhavan.counter</code>, <code>Student.counter</code> remains unchanged because <code>madhavan.counter</code> gets delinked from <code>Student.counter</code> and becomes a new object attribute specific to <code>madhavan</code>. To change <code>Student.counter</code>:</p> <pre><code>Student.counter = 0\nprint(Student.counter)\n</code></pre> OUTPUT <pre><code>Student counter: 0\n</code></pre> <p>Now try this as an exercise and try to figure out why the output is the way it is:</p> <pre><code>print(\"Usha counter:\", usha.counter)\nprint(\"Madhavan counter:\", madhavan.counter)\nRohan = Student('Rohan', 40)\nprint(\"Student counter:\", Student.counter)\nprint(\"Usha counter:\", usha.counter)\nprint(\"Madhavan counter:\", madhavan.counter)\n</code></pre> OUTPUT <pre><code>Usha counter: 0\nMadhavan counter: -1\nStudent counter: 1\nUsha counter: 1\nMadhavan counter: -1\n</code></pre> <p>This demonstrates an important fact: class attributes cannot be updated by an object! At best, they can be referenced or accessed using an object</p> <p>This also introduces another important point: object attributes can be created dynamically during runtime. So far, we have seen object attributes being created within the constructor. This is not binding. For example, consider the following snippet:</p> <pre><code>class Student:\n    def __init__(self, name):\n        self.name = name\n\nanish = Student('Anish')\nanish.maths = 100\nanish.physics = 90\nanish.chem = 70\n</code></pre> <p>We have created three more object attributes on the fly. It is interesting to note the subtle difference between the attribute <code>name</code> and the three new attributes <code>maths</code>, <code>physics</code> and <code>chem</code>. Any object of <code>Student</code> will have the attribute <code>name</code> when it is initially created, of course with a different value for <code>name</code> depending on the object. But the attributes <code>maths</code>, <code>physics</code> and <code>chem</code> are unique to the object <code>anish</code>.</p>"},{"location":"chapter-8/lesson-8.3/","title":"Lesson 8.3","text":""},{"location":"chapter-8/lesson-8.3/#lesson-83","title":"Lesson 8.3","text":""},{"location":"chapter-8/lesson-8.3/#inheritance","title":"Inheritance","text":"<p>Let us get back to the fundamental philosophical idea with which we began the study of object oriented programming.</p> <p>Unity in diversity.</p> <p>The idea of a class represents the unity, the idea of objects represent the diversity. But this diversity that we see around us is not chaotic and unordered. On the contrary, there is an organized hierarchy that we see almost everywhere around us. Consider the following image:</p> <p></p> <p>We humans take up different roles. Some of us are students, others are working professionals. The beauty of this program is that we have working professionals who are at the same time students. Getting back to the point, we see that there is a hierarchy. All college students are students. All students are humans. In the other branch of this directed graph, all full-stack developers are software developers, all software developers are working professionals. The basic idea behind the concept of inheritance is this:</p> <p>Classes that are lower in the hierarchy inherit features or attributes from their ancestors.</p> <p>There are certain features of a class higher up in the hierarchy that can be inherited by classes lower in the hierarchy. For example, all working professionals draw a salary every month. All software developers also draw some monthly salary, because they belong to the class of working professionals. So, salary is an attribute that is common to all classes that are derived from the class of working professionals. Needless to say, a full stack developer inherits this attribute of salary from his ancestors in the graph.</p> <p>We shall take up a concrete example and see inheritance in action.</p>"},{"location":"chapter-8/lesson-8.3/#concrete-example","title":"Concrete Example","text":"<p>By now you would have worked on plenty of assignments across multiple courses. Each assignment is a collection of questions. Questions come in different types, some are NAT, some MCQ. So, a NAT question is not of the same type as a MCQ question. Yet, both are questions. So, we see that there is a hierarchy of relationships here:</p> <p></p> <p>Parents always come first in the hierarchy. So, let us first define a class to represent a question:</p> <pre><code>class Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n\n    def print_question(self):\n        print(self.statement)\n\n    def update_marks(self, marks):\n        self.marks = marks\n</code></pre> <p>Note that we have only retained those elements as attributes that are common to all questions, irrespective of the type:</p> <ul> <li>statement of the question</li> <li>marks for the question</li> </ul> <p>The next step is to define two new classes for the children of <code>Question</code>, one for MCQ and the other for NAT. It is here that we make use of the relationship that we just diagrammed:</p> <pre><code>class NAT(Question):\n    def __init__(self, statement, marks, answer):\n        super().__init__(statement, marks)\n        self.answer = answer\n\n    def update_answer(self, answer):\n        self.answer = answer\n</code></pre> <p><code>NAT</code> is also a <code>Question</code>, but a specialized question. Specifically, it has an additional feature, <code>answer</code>, and a new method, <code>update_answer</code>. But all the other attributes and methods of <code>Question</code> are inherited by it, since <code>NAT</code> is just another <code>Question</code>.</p> <p>We say that <code>NAT</code> is derived from <code>Question</code>. <code>Question</code> becomes the parent-class or base-class , and <code>NAT</code> is a child-class or derived-class.</p> <p></p> <p>In Python, the syntax used to make this dependency explicit is as follows:</p> <pre><code>class Derived(Base):\n    def __init__(self, ...):\n        pass\n\n#### OR ####\nclass Child(Parent):\n    def __init__(self, ...):\n        ...\n</code></pre> <p>In our specific example, we have:</p> <pre><code>class NAT(Question):\n    def __init__(self, ...):\n        pass\n</code></pre>"},{"location":"chapter-8/lesson-8.3/#parent-child-relationship","title":"Parent-child relationship","text":"<p>Note that something interesting happens within the constructor of the derived class:</p> <pre><code>class NAT(Question):\n    def __init__(self, statement, marks, answer):\n        super().__init__(statement, marks)\n        self.answer = answer\n\n    def update_answer(self, answer):\n        self.answer = answer\n</code></pre> <p>The <code>super()</code> function points to the parent class, in this case <code>Question</code>. So, in line 13, we are effectively calling the constructor of the parent class. If we need to update the marks, we can just invoke the method <code>update_marks()</code> that is inherited from <code>Question</code>:</p> <pre><code>q_nat = NAT('What is 1 + 1?', 1, 2)\nq_nat.update_marks(4)\nprint(q_nat.marks)\n</code></pre> OUTPUT <pre><code>4\n</code></pre>"},{"location":"chapter-8/lesson-8.3/#method-overriding","title":"Method Overriding","text":"<p>Let us now turn our attention to methods. Pasting the parent-class here for easy reference:</p> <pre><code>class Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n\n    def print_question(self):\n        print(self.statement)\n\n    def update_marks(self, marks):\n        self.marks = marks\n</code></pre> <p>Sometimes we may want to modify the behaviour of existing methods in the parent class. For example, take the case of a MCQ question. For questions of this type, the statement of a problem is incomplete without the options. The <code>print_question()</code> method in the parent class just prints the statement, but it makes more sense to print the options as well for a MCQ question. So, we want the <code>print_question()</code> to behave differently. Though we have inherited this method from the parent class, we can override the behaviour of the method in the following way:</p> <pre><code>class MCQ(Question):\n    def __init__(self, statement, marks, ops, c_ops):\n        super().__init__(statement, marks)\n        self.ops = ops      # list of all options\n        self.c_ops = c_ops  # list of correct options\n\n    def print_question(self):\n        super().print_question()\n        # Assume there are only four options\n        op_index = ['(a)', '(b)', '(c)', '(d)']\n        for i in range(4):\n            print(op_index[i], self.ops[i])\n</code></pre> <p>Note that the parent class <code>Question</code> already prints the statement. So, we piggy-back on this behaviour using the <code>super()</code> function in line-8. In addition, we also print the options. Let us create a <code>MCQ</code> question object and see how it all works:</p> <pre><code>q_mcq = MCQ('What is the capital of India?',\n           2,\n           ['Chennai', 'Mumbai', 'Kolkota', 'New Delhi'],\n           ['New Delhi'])\nq_mcq.print_question()\n</code></pre> <p>This returns the output:</p> OUTPUT <pre><code>What is the capital of India?\n(a) Chennai\n(b) Mumbai\n(c) Kolkota\n(d) New Delhi\n</code></pre>"},{"location":"chapter-8/lesson-8.4/","title":"Lesson 8.4","text":""},{"location":"chapter-8/lesson-8.4/#lesson-84","title":"Lesson 8.4","text":"<p>We will take up one final example of classes in action. This is to demonstrate few important points about OOP along the way.</p>"},{"location":"chapter-8/lesson-8.4/#vector-mathematical-preliminaries","title":"Vector: Mathematical Preliminaries","text":"<p>To each point \\(P(x, y)\\) in 2D space, we can associate what is called a vector. Geometrically, this is a directed arrow from the origin to the point \\(P\\). That is, one tip of the vector will always be the origin and the other tip, also called the head of the vector, will be at the point \\(P\\). Here, \\(P_1\\) and \\(P_2\\) are two vectors:</p> <p></p> <p>Some operations on vectors:</p>"},{"location":"chapter-8/lesson-8.4/#magnitude","title":"Magnitude","text":"<p>The magnitude of a vector \\(P(x, y)\\) is the length of the line segment \\(OP\\): $$ |OP| = \\sqrt{x^2 + y^2} $$</p>"},{"location":"chapter-8/lesson-8.4/#scale","title":"Scale","text":"<p>A vector can be scaled by a value \\(s\\). Scaling modifies the length of the vector without changing the direction in which it is pointing at. This is equivalent to the following transformation: $$ s \\cdot (x, y) \\rightarrow (sx, sy) $$</p>"},{"location":"chapter-8/lesson-8.4/#add","title":"Add","text":"<p>Two vectors \\(P_1(x_1, y_1)\\) and \\(P_2(x_2, y_2)\\) can be added in the following manner: $$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $$ For example:</p> <p></p>"},{"location":"chapter-8/lesson-8.4/#reflect","title":"Reflect","text":"<p>A vector can be rotated about the origin. A particular instance of rotation is reflection about an axis. For example, \\(P_r\\) is the reflection of \\(P\\) about the X-axis:</p> <p></p> <p>This corresponds to the transformation: $$ (x, y) \\rightarrow (x, -y) $$</p>"},{"location":"chapter-8/lesson-8.4/#vector-specification","title":"Vector: Specification","text":"<p>From the mathematical vector, we need to transition to the programmatic vector. The bridge between these two states is the specification. In this step, we come up with a written description of the attributes and methods that our <code>Vector</code> class should possess. The source for this information comes from the mathematical vector that we just studied.</p> <p>The following is the specification of the <code>Vector</code> class:</p>"},{"location":"chapter-8/lesson-8.4/#attributes","title":"Attributes","text":"<ul> <li><code>x</code>: the x-coordinate of the vector</li> <li><code>y</code>: the y-coordinate of the vector</li> </ul> <p>This choice is sufficient as any mathematical vector in 2D space can be completely defined with these two attributes.</p>"},{"location":"chapter-8/lesson-8.4/#methods","title":"Methods","text":"<ul> <li><code>__init__()</code>: constructor of the class; populate the attributes based on the arguments</li> <li><code>__str__()</code>: return the coordinates of the vector in the form <code>(x,y)</code> when you call the <code>str()</code> or <code>print()</code> functions on a <code>Vector</code> object.</li> <li><code>magnitude()</code>: return the magnitude of the vector</li> <li><code>scale()</code>: scale the vector by some number, \\(s\\); this transformation should be applied on the current vector</li> <li><code>rotate_xaxis()</code>: reflect the vector about the X-axis; this transformation should be applied on the current vector</li> <li><code>rotate_yaxis()</code>: reflect the vector about the Y-axis; this transformation should be applied on the current vector</li> <li><code>add()</code>: accept a vector as argument; return the sum of this argument with the current vector</li> </ul>"},{"location":"chapter-8/lesson-8.4/#vector-definition","title":"Vector: Definition","text":"<p>The stage is now set to define the class:</p> <pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def print(self):\n        return f'({self.x},{self.y})'\n    def magnitude(self):\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n    def scale(self, s):\n        self.x, self.y = self.x * s, self.y * s\n    def rotate_xaxis(self):\n        self.y = -self.y\n    def rotate_yaxis(self):\n        self.x = -self.x\n    def add(self, P):\n        result = Vector(0, 0)\n        result.x, result.y = self.x + P.x, self.y + P.y\n        return result\n</code></pre> <p>Most methods are self-explanatory. Some require closer attention. Note that all methods except <code>add()</code> and <code>__str__()</code> do not return any value. These are methods that transform the vector itself. The method <code>add()</code> however is interesting. It accepts a vector <code>P</code> as an argument! Within the method, a new <code>Vector</code> object is defined, it is the zero-vector. The current vector is added with <code>P</code> and result is stored in the newly created vector <code>result</code>. This is finally returned.</p>"},{"location":"chapter-8/lesson-8.4/#collection-of-vectors","title":"Collection of Vectors","text":"<p>The whole point of having a class is to have objects. The class is just a template. Consider the following use case of a collection of objects:</p> <pre><code>triangle = [Vector(0, 1), Vector(3, 1), Vector(3, 0)]\n</code></pre> <p>The list <code>triangle</code> is a collection of objects of type <code>Vector</code>. In this instance, <code>triangle</code> represents the following triangle:</p> <p></p> <p>We could now ask various questions here, one of which is this: how do we compute the lengths of the sides of this triangle?</p> <pre><code>def dist(P1, P2):\n    return ((P1.x - P2.x) ** 2 + (P1.y - P2.y) ** 2) ** 0.5\n\ndef side_lengths(triangle):\n    la = dist(triangle[0], triangle[1])\n    lb = dist(triangle[1], triangle[2])\n    lc = dist(triangle[2], triangle[0])\n    return la, lb, lc\n</code></pre> <p>In this way, we could also define a square to be a list of four vectors. That brings to a close the discussion on object oriented programming in Python. We will cover these concepts in greater detail when we study Java.</p>"},{"location":"extras/limits/","title":"Shorts","text":""},{"location":"extras/limits/#shorts","title":"Shorts","text":"<p>Before we close this chapter, let us spend some time at the intersection of mathematics and programming. Consider the following number: $$ \\sqrt{2} - 1 $$ It is known that \\(1 &lt; \\sqrt{2} &lt; 2\\). From this, it follows that \\(0 &lt; \\sqrt{2} - 1 &lt; 1\\). Now, consider the following sequence: $$ a_n = \\left( \\sqrt{2} - 1 \\right)^n $$ As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically:</p> <pre><code>n = int(input())        # sequence length\nCONST = 2 ** 0.5 - 1    # basic term in the sequence\na_n = 1                 # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST\nprint(a_n)\n</code></pre> <p>Try this out for a few values of \\(n\\). For \\(n = 100\\), the value is \\(5.27 \\times 10^{-39}\\), which is so small that for all practical purposes, it is as good as zero.  Now, here is another fact. For every number \\(n\\), there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ This can be verified for the first few values of \\(n\\). The following is a sketch of an inductive proof that this is indeed the case. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\), then: $$ \\begin{align} (\\sqrt{2} - 1)^{n + 1} &amp;= (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ &amp;= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ &amp;= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} \\end{align} $$ This gives us a programmatic way to compute the \\(n^{th}\\) power of \\(\\sqrt{2} - 1\\) in the above form:</p> <pre><code>n = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\n</code></pre> <p>This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.</p>"},{"location":"extras/resources/","title":"Resources","text":""},{"location":"extras/resources/#resources","title":"Resources","text":"<p>This section provides additional resources in the form of articles and blogs that are scattered around the web:</p> <ul> <li>Dropbox | Dynamic typing</li> <li>Python's Functions are First-Class</li> <li>Memory address of a Function</li> <li>Understanding slicing</li> <li>Migration to Python 3</li> </ul>"}]}